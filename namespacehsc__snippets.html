<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>snippets: hsc_snippets Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">snippets<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">hsc_snippets Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1BigInteger.html">BigInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a class for representing and manipulating large integers beyond the native integer range.  <a href="classhsc__snippets_1_1BigInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1DominantTracker.html">DominantTracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1IntervalMap.html">IntervalMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1IntervalSet.html">IntervalSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1Maximum.html">Maximum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1MonotonicStack.html">MonotonicStack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1Override.html">Override</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1SegmentTree.html">SegmentTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1SlidingWindowMax.html">SlidingWindowMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1UnionFind.html">UnionFind</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concepthsc__snippets_1_1numeric.html">numeric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9cbfd0b02206d45ef53cae53da08bde1" id="r_a9cbfd0b02206d45ef53cae53da08bde1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9cbfd0b02206d45ef53cae53da08bde1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9cbfd0b02206d45ef53cae53da08bde1">MonotonicDecreasingStack</a> = <a class="el" href="classhsc__snippets_1_1MonotonicStack.html">MonotonicStack</a>&lt;T, std::less_equal&lt;T&gt;&gt;</td></tr>
<tr class="separator:a9cbfd0b02206d45ef53cae53da08bde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38155ad9e921ee6d3cf69b328f69757" id="r_aa38155ad9e921ee6d3cf69b328f69757"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa38155ad9e921ee6d3cf69b328f69757"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa38155ad9e921ee6d3cf69b328f69757">MonotonicIncreasingStack</a> = <a class="el" href="classhsc__snippets_1_1MonotonicStack.html">MonotonicStack</a>&lt;T, std::greater_equal&lt;T&gt;&gt;</td></tr>
<tr class="separator:aa38155ad9e921ee6d3cf69b328f69757"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2d713b7bb2ef09fac4d0b640185b52b4" id="r_a2d713b7bb2ef09fac4d0b640185b52b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d713b7bb2ef09fac4d0b640185b52b4">new_binary_tree</a> (const std::vector&lt; std::optional&lt; int &gt; &gt; v)</td></tr>
<tr class="separator:a2d713b7bb2ef09fac4d0b640185b52b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429782e4ffeba328dbfc0339166d667c" id="r_a429782e4ffeba328dbfc0339166d667c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a429782e4ffeba328dbfc0339166d667c">delete_binary_tree</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root)</td></tr>
<tr class="separator:a429782e4ffeba328dbfc0339166d667c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cce75b709a679ebc99a4abcdbbd7bd" id="r_a26cce75b709a679ebc99a4abcdbbd7bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26cce75b709a679ebc99a4abcdbbd7bd">get_binary_tree_depth</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root)</td></tr>
<tr class="separator:a26cce75b709a679ebc99a4abcdbbd7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c82b125272d02d5cdaa2169f225f85" id="r_ac6c82b125272d02d5cdaa2169f225f85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6c82b125272d02d5cdaa2169f225f85">inorder</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root, std::function&lt; void(int)&gt; func)</td></tr>
<tr class="separator:ac6c82b125272d02d5cdaa2169f225f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32df3d871f5bcd99ec98038fe7d7ae02" id="r_a32df3d871f5bcd99ec98038fe7d7ae02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32df3d871f5bcd99ec98038fe7d7ae02">preorder</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root, std::function&lt; void(int)&gt; func)</td></tr>
<tr class="separator:a32df3d871f5bcd99ec98038fe7d7ae02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8f2987db631e9af726376704c355b8" id="r_a6f8f2987db631e9af726376704c355b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f8f2987db631e9af726376704c355b8">postorder</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root, std::function&lt; void(int)&gt; func)</td></tr>
<tr class="separator:a6f8f2987db631e9af726376704c355b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8052840df1ce8e295a2d69d656d836d5" id="r_a8052840df1ce8e295a2d69d656d836d5"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; int, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8052840df1ce8e295a2d69d656d836d5">binary_tree_to_adjacency_list</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root)</td></tr>
<tr class="separator:a8052840df1ce8e295a2d69d656d836d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3309599331a5cdd33769faddfefca01b" id="r_a3309599331a5cdd33769faddfefca01b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3309599331a5cdd33769faddfefca01b">make_weighted_directed_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:a3309599331a5cdd33769faddfefca01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6652ea3101ac6cfdad917c467930b521" id="r_a6652ea3101ac6cfdad917c467930b521"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6652ea3101ac6cfdad917c467930b521">make_unweighted_undirected_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:a6652ea3101ac6cfdad917c467930b521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8cb2639fba615716c6ce0717de2e9e" id="r_a6d8cb2639fba615716c6ce0717de2e9e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d8cb2639fba615716c6ce0717de2e9e">make_weighted_undirected_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:a6d8cb2639fba615716c6ce0717de2e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00180746e48d290f32ebbbeb663a3aa" id="r_aa00180746e48d290f32ebbbeb663a3aa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa00180746e48d290f32ebbbeb663a3aa">make_unweighted_directed_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:aa00180746e48d290f32ebbbeb663a3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bf74759d725b5eaffb0609b370eecc" id="r_a94bf74759d725b5eaffb0609b370eecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94bf74759d725b5eaffb0609b370eecc">breadth_first_search</a> (std::vector&lt; std::vector&lt; int &gt; &gt; &amp;adjacency_list, int root, std::function&lt; void(int, int)&gt; callback)</td></tr>
<tr class="separator:a94bf74759d725b5eaffb0609b370eecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa53f26ca29b00677b58dfbd3957fb6" id="r_aefa53f26ca29b00677b58dfbd3957fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefa53f26ca29b00677b58dfbd3957fb6">breadth_first_search</a> (std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; &amp;adjacency_list, int root, std::function&lt; void(int, int)&gt; callback)</td></tr>
<tr class="separator:aefa53f26ca29b00677b58dfbd3957fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a409659bd176a384e5ebd1ec86ccb8" id="r_a85a409659bd176a384e5ebd1ec86ccb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a409659bd176a384e5ebd1ec86ccb8">depth_first_search</a> (std::vector&lt; std::vector&lt; int &gt; &gt; &amp;adjacency_list, int root, std::function&lt; void(int, int)&gt; callback)</td></tr>
<tr class="separator:a85a409659bd176a384e5ebd1ec86ccb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ea360ca73fc90de39097acf5adb5a8" id="r_ae9ea360ca73fc90de39097acf5adb5a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9ea360ca73fc90de39097acf5adb5a8">dijkstra</a> (int n, const std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt; &amp;adjacency_list, int src, int dst)</td></tr>
<tr class="separator:ae9ea360ca73fc90de39097acf5adb5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a72d9be388b969808af9cd6617aea9" id="r_a50a72d9be388b969808af9cd6617aea9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50a72d9be388b969808af9cd6617aea9">find_euler_path_directed</a> (const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:a50a72d9be388b969808af9cd6617aea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dd678bffb7adede9bc2eabe0e92665" id="r_a16dd678bffb7adede9bc2eabe0e92665"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16dd678bffb7adede9bc2eabe0e92665">findConnectedComponents</a> (std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; &amp;adj)</td></tr>
<tr class="separator:a16dd678bffb7adede9bc2eabe0e92665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434872c7db853da32dcaf6254abf53bd" id="r_a434872c7db853da32dcaf6254abf53bd"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a434872c7db853da32dcaf6254abf53bd"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a434872c7db853da32dcaf6254abf53bd">operator&lt;</a> (const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;interval, T x)</td></tr>
<tr class="separator:a434872c7db853da32dcaf6254abf53bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4893ca5a1d94f3b1c7ed3768bb4c3a3a" id="r_a4893ca5a1d94f3b1c7ed3768bb4c3a3a"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a4893ca5a1d94f3b1c7ed3768bb4c3a3a"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4893ca5a1d94f3b1c7ed3768bb4c3a3a">operator&lt;</a> (T x, const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;interval)</td></tr>
<tr class="separator:a4893ca5a1d94f3b1c7ed3768bb4c3a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46c82943972e1cda8e400b287ca10e4" id="r_ad46c82943972e1cda8e400b287ca10e4"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:ad46c82943972e1cda8e400b287ca10e4"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad46c82943972e1cda8e400b287ca10e4">operator&lt;</a> (const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;interval1, const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;interval2)</td></tr>
<tr class="separator:ad46c82943972e1cda8e400b287ca10e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac491df2754ee69d6ba83dfd256c3c079" id="r_ac491df2754ee69d6ba83dfd256c3c079"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac491df2754ee69d6ba83dfd256c3c079">get_linked_list_length</a> (<a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *head)</td></tr>
<tr class="separator:ac491df2754ee69d6ba83dfd256c3c079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d00610b7e210a53730c9ffdfeba57b9" id="r_a1d00610b7e210a53730c9ffdfeba57b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d00610b7e210a53730c9ffdfeba57b9">make_linked_list</a> (const std::vector&lt; int &gt; &amp;v)</td></tr>
<tr class="separator:a1d00610b7e210a53730c9ffdfeba57b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753a3ebbdd118444fed6c922d57de01f" id="r_a753a3ebbdd118444fed6c922d57de01f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a753a3ebbdd118444fed6c922d57de01f">linked_list_to_vector</a> (<a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *head)</td></tr>
<tr class="separator:a753a3ebbdd118444fed6c922d57de01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad242c8792daef6564483babc4db2e7ca" id="r_ad242c8792daef6564483babc4db2e7ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad242c8792daef6564483babc4db2e7ca">linked_list_delete</a> (<a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *head)</td></tr>
<tr class="separator:ad242c8792daef6564483babc4db2e7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cb53700e41ce0806b784d51afe7aaa" id="r_a40cb53700e41ce0806b784d51afe7aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40cb53700e41ce0806b784d51afe7aaa">linked_list_remove</a> (<a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *head, size_t begin, size_t end)</td></tr>
<tr class="separator:a40cb53700e41ce0806b784d51afe7aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c058184d3bf4b4028ac27888f891666" id="r_a7c058184d3bf4b4028ac27888f891666"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c058184d3bf4b4028ac27888f891666">modular_add</a> (int x, int y)</td></tr>
<tr class="separator:a7c058184d3bf4b4028ac27888f891666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795dc74a07970f538ab222b31f874271" id="r_a795dc74a07970f538ab222b31f874271"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a795dc74a07970f538ab222b31f874271">additive_inverse</a> (int x)</td></tr>
<tr class="separator:a795dc74a07970f538ab222b31f874271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b88bd1961aeceb11486a737609e862" id="r_af5b88bd1961aeceb11486a737609e862"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5b88bd1961aeceb11486a737609e862">modular_substract</a> (int x, int y)</td></tr>
<tr class="separator:af5b88bd1961aeceb11486a737609e862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dc1f9c8622b338e040c3d0746ffa45" id="r_a36dc1f9c8622b338e040c3d0746ffa45"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36dc1f9c8622b338e040c3d0746ffa45">modular_multiply</a> (int x, int y)</td></tr>
<tr class="separator:a36dc1f9c8622b338e040c3d0746ffa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24c9c4d4245ec401fd40ecb1a12c1b6" id="r_ab24c9c4d4245ec401fd40ecb1a12c1b6"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab24c9c4d4245ec401fd40ecb1a12c1b6">modular_square</a> (int x)</td></tr>
<tr class="separator:ab24c9c4d4245ec401fd40ecb1a12c1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f0c52364cd0e82d19151f1d05aee8c" id="r_a69f0c52364cd0e82d19151f1d05aee8c"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69f0c52364cd0e82d19151f1d05aee8c">modular_cube</a> (int x)</td></tr>
<tr class="separator:a69f0c52364cd0e82d19151f1d05aee8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72561173b55e31dc534d5f5612a52246" id="r_a72561173b55e31dc534d5f5612a52246"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72561173b55e31dc534d5f5612a52246">modular_pow2</a> (size_t exponent)</td></tr>
<tr class="separator:a72561173b55e31dc534d5f5612a52246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ccbeb569860677c784f504351db1d8" id="r_a58ccbeb569860677c784f504351db1d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58ccbeb569860677c784f504351db1d8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58ccbeb569860677c784f504351db1d8">nextGreaterElement</a> (const std::vector&lt; T &gt; &amp;nums, std::function&lt; T()&gt; no_greater)</td></tr>
<tr class="separator:a58ccbeb569860677c784f504351db1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bc199445ac13f4653bf795c24cdf08" id="r_ac9bc199445ac13f4653bf795c24cdf08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9bc199445ac13f4653bf795c24cdf08">largestRectangleInHistogram</a> (const std::vector&lt; int &gt; &amp;heights)</td></tr>
<tr class="separator:ac9bc199445ac13f4653bf795c24cdf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21faa054d1afffbd2d869a99a54209de" id="r_a21faa054d1afffbd2d869a99a54209de"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a21faa054d1afffbd2d869a99a54209de"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21faa054d1afffbd2d869a99a54209de">numDigits</a> (T num)</td></tr>
<tr class="separator:a21faa054d1afffbd2d869a99a54209de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc8f948cda1de6cbdb67bf6680d87f9" id="r_a9dc8f948cda1de6cbdb67bf6680d87f9"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a9dc8f948cda1de6cbdb67bf6680d87f9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9dc8f948cda1de6cbdb67bf6680d87f9">numBits</a> (T num)</td></tr>
<tr class="separator:a9dc8f948cda1de6cbdb67bf6680d87f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff61e6f2efed27bc4bbb2a2c6a44328" id="r_afff61e6f2efed27bc4bbb2a2c6a44328"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:afff61e6f2efed27bc4bbb2a2c6a44328"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afff61e6f2efed27bc4bbb2a2c6a44328">gcd</a> (T a, T b)</td></tr>
<tr class="separator:afff61e6f2efed27bc4bbb2a2c6a44328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d31a87aa5ed5297257e6daea49a4c72" id="r_a9d31a87aa5ed5297257e6daea49a4c72"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a9d31a87aa5ed5297257e6daea49a4c72"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d31a87aa5ed5297257e6daea49a4c72">lcm</a> (T a, T b)</td></tr>
<tr class="separator:a9d31a87aa5ed5297257e6daea49a4c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d5f09b15d654e057d86fee902cab7d" id="r_a18d5f09b15d654e057d86fee902cab7d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18d5f09b15d654e057d86fee902cab7d">SieveOfEratosthenes</a> (int n)</td></tr>
<tr class="separator:a18d5f09b15d654e057d86fee902cab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97059b7ec97027b3b47ca79786b8704f" id="r_a97059b7ec97027b3b47ca79786b8704f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97059b7ec97027b3b47ca79786b8704f">subarraysWithAtMostKDistinct</a> (const std::vector&lt; int &gt; &amp;nums, int k)</td></tr>
<tr class="separator:a97059b7ec97027b3b47ca79786b8704f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770cc063eb04b7231b755c72383511d3" id="r_a770cc063eb04b7231b755c72383511d3"><td class="memTemplParams" colspan="2">template&lt;std::totally_ordered T&gt; </td></tr>
<tr class="memitem:a770cc063eb04b7231b755c72383511d3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a770cc063eb04b7231b755c72383511d3">numOfGreaterElements</a> (const std::vector&lt; T &gt; &amp;v, T value)</td></tr>
<tr class="separator:a770cc063eb04b7231b755c72383511d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f76e1d412f83567b03ef84aa374878a" id="r_a2f76e1d412f83567b03ef84aa374878a"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a2f76e1d412f83567b03ef84aa374878a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2f76e1d412f83567b03ef84aa374878a">containsInRange</a> (const std::vector&lt; T &gt; &amp;vec, T start, T end)</td></tr>
<tr class="separator:a2f76e1d412f83567b03ef84aa374878a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19a8c1f33cd0fbc24e3ea9d093430d1" id="r_ab19a8c1f33cd0fbc24e3ea9d093430d1"><td class="memTemplParams" colspan="2">template&lt;typename T , std::integral I = int&gt; </td></tr>
<tr class="memitem:ab19a8c1f33cd0fbc24e3ea9d093430d1"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab19a8c1f33cd0fbc24e3ea9d093430d1">binary_search</a> (I low, I high, const T &amp;value, auto &amp;&amp;func)</td></tr>
<tr class="separator:ab19a8c1f33cd0fbc24e3ea9d093430d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f93655a4a72d10c318c290783a2bdc" id="r_ac7f93655a4a72d10c318c290783a2bdc"><td class="memTemplParams" colspan="2">template&lt;typename T , std::integral I = int&gt; </td></tr>
<tr class="memitem:ac7f93655a4a72d10c318c290783a2bdc"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac7f93655a4a72d10c318c290783a2bdc">greatest_index</a> (I low, I high, const T &amp;value, auto &amp;&amp;func)</td></tr>
<tr class="separator:ac7f93655a4a72d10c318c290783a2bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3d0574aec6857720f3494a33cc7a85" id="r_a8b3d0574aec6857720f3494a33cc7a85"><td class="memTemplParams" colspan="2">template&lt;typename T , std::integral I = int&gt; </td></tr>
<tr class="memitem:a8b3d0574aec6857720f3494a33cc7a85"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b3d0574aec6857720f3494a33cc7a85">smallest_index</a> (I low, I high, const T &amp;value, auto &amp;&amp;func)</td></tr>
<tr class="separator:a8b3d0574aec6857720f3494a33cc7a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdb05e51cc5a1ab1a9b3aea8075b2ef" id="r_adbdb05e51cc5a1ab1a9b3aea8075b2ef"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:adbdb05e51cc5a1ab1a9b3aea8075b2ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbdb05e51cc5a1ab1a9b3aea8075b2ef">sortThree</a> (T &amp;a, T &amp;b, T &amp;c)</td></tr>
<tr class="separator:adbdb05e51cc5a1ab1a9b3aea8075b2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae063eb2bd48343750f3472eeb0320a38" id="r_ae063eb2bd48343750f3472eeb0320a38"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae063eb2bd48343750f3472eeb0320a38">kmpSearch</a> (const std::string &amp;pat, const std::string &amp;txt)</td></tr>
<tr class="separator:ae063eb2bd48343750f3472eeb0320a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1228660ec00e385121ef6171dc80d2be" id="r_a1228660ec00e385121ef6171dc80d2be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1228660ec00e385121ef6171dc80d2be">isPalindrome</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a1228660ec00e385121ef6171dc80d2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5a6b2a2e32759546fc105652ee34c6" id="r_aea5a6b2a2e32759546fc105652ee34c6"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:aea5a6b2a2e32759546fc105652ee34c6"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea5a6b2a2e32759546fc105652ee34c6">to_string</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:aea5a6b2a2e32759546fc105652ee34c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c60972c6e940cc87036321ae5c5136" id="r_aa6c60972c6e940cc87036321ae5c5136"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:aa6c60972c6e940cc87036321ae5c5136"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6c60972c6e940cc87036321ae5c5136">to_string</a> (std::pair&lt; T, T &gt; p)</td></tr>
<tr class="separator:aa6c60972c6e940cc87036321ae5c5136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ec3e40e27b79ffc33545635fba4503" id="r_a99ec3e40e27b79ffc33545635fba4503"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a99ec3e40e27b79ffc33545635fba4503"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99ec3e40e27b79ffc33545635fba4503">to_string</a> (const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;vec)</td></tr>
<tr class="separator:a99ec3e40e27b79ffc33545635fba4503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64970a5102d416fdd499f71c3cd1000f" id="r_a64970a5102d416fdd499f71c3cd1000f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64970a5102d416fdd499f71c3cd1000f">to_string</a> (const std::vector&lt; std::string &gt; &amp;vec)</td></tr>
<tr class="separator:a64970a5102d416fdd499f71c3cd1000f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611d2268215b58fd16cde84613d4fc6b" id="r_a611d2268215b58fd16cde84613d4fc6b"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a611d2268215b58fd16cde84613d4fc6b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a611d2268215b58fd16cde84613d4fc6b">to_string</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;vec)</td></tr>
<tr class="separator:a611d2268215b58fd16cde84613d4fc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bc4b2d7435fc0d95a1faa768e08797" id="r_a57bc4b2d7435fc0d95a1faa768e08797"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57bc4b2d7435fc0d95a1faa768e08797">split</a> (const std::string &amp;s, char delimiter)</td></tr>
<tr class="separator:a57bc4b2d7435fc0d95a1faa768e08797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6691641b2d50eca1b2145da55c74f1d" id="r_ac6691641b2d50eca1b2145da55c74f1d"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:ac6691641b2d50eca1b2145da55c74f1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6691641b2d50eca1b2145da55c74f1d">lessThanAll</a> (T x, T val)</td></tr>
<tr class="separator:ac6691641b2d50eca1b2145da55c74f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c0498b1070c4404daaaf087992758b" id="r_ae5c0498b1070c4404daaaf087992758b"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:ae5c0498b1070c4404daaaf087992758b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5c0498b1070c4404daaaf087992758b">lessThanAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:ae5c0498b1070c4404daaaf087992758b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9c656f40560cd6141ff708c5937b89" id="r_a8f9c656f40560cd6141ff708c5937b89"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a8f9c656f40560cd6141ff708c5937b89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f9c656f40560cd6141ff708c5937b89">lessThanOrEqualToAll</a> (T x, T val)</td></tr>
<tr class="separator:a8f9c656f40560cd6141ff708c5937b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e874c9c2bfef67800a520d9ccf60805" id="r_a0e874c9c2bfef67800a520d9ccf60805"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:a0e874c9c2bfef67800a520d9ccf60805"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e874c9c2bfef67800a520d9ccf60805">lessThanOrEqualToAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:a0e874c9c2bfef67800a520d9ccf60805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9919b9e521c5513278a973e42a1bbf42" id="r_a9919b9e521c5513278a973e42a1bbf42"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a9919b9e521c5513278a973e42a1bbf42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9919b9e521c5513278a973e42a1bbf42">greaterThanAll</a> (T x, T val)</td></tr>
<tr class="separator:a9919b9e521c5513278a973e42a1bbf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca360e3bd41a5aa9aa1873147e5bc823" id="r_aca360e3bd41a5aa9aa1873147e5bc823"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:aca360e3bd41a5aa9aa1873147e5bc823"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca360e3bd41a5aa9aa1873147e5bc823">greaterThanAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:aca360e3bd41a5aa9aa1873147e5bc823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c76cdee93b66ddae3fa5a37b42f19d" id="r_a21c76cdee93b66ddae3fa5a37b42f19d"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a21c76cdee93b66ddae3fa5a37b42f19d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21c76cdee93b66ddae3fa5a37b42f19d">greaterThanOrEqualToAll</a> (T x, T val)</td></tr>
<tr class="separator:a21c76cdee93b66ddae3fa5a37b42f19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97854002bbec586ad6d0a52ab4315e3" id="r_ae97854002bbec586ad6d0a52ab4315e3"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:ae97854002bbec586ad6d0a52ab4315e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae97854002bbec586ad6d0a52ab4315e3">greaterThanOrEqualToAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:ae97854002bbec586ad6d0a52ab4315e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6dae9bb445381d5ec6a88094c9f315" id="r_a3e6dae9bb445381d5ec6a88094c9f315"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a3e6dae9bb445381d5ec6a88094c9f315"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e6dae9bb445381d5ec6a88094c9f315">sum</a> (T x)</td></tr>
<tr class="separator:a3e6dae9bb445381d5ec6a88094c9f315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabb6992d6adc87e88949774ea718c67" id="r_adabb6992d6adc87e88949774ea718c67"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:adabb6992d6adc87e88949774ea718c67"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adabb6992d6adc87e88949774ea718c67">sum</a> (T x, Args... args)</td></tr>
<tr class="separator:adabb6992d6adc87e88949774ea718c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a218d0181825bcf526ca9e5c24f6aab06" id="r_a218d0181825bcf526ca9e5c24f6aab06"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a> = static_cast&lt;int&gt;(1e9 + 7)</td></tr>
<tr class="separator:a218d0181825bcf526ca9e5c24f6aab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9cbfd0b02206d45ef53cae53da08bde1" name="a9cbfd0b02206d45ef53cae53da08bde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbfd0b02206d45ef53cae53da08bde1">&#9670;&#160;</a></span>MonotonicDecreasingStack</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9cbfd0b02206d45ef53cae53da08bde1">hsc_snippets::MonotonicDecreasingStack</a> = <a class="el" href="classhsc__snippets_1_1MonotonicStack.html">MonotonicStack</a>&lt;T, std::less_equal&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa38155ad9e921ee6d3cf69b328f69757" name="aa38155ad9e921ee6d3cf69b328f69757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38155ad9e921ee6d3cf69b328f69757">&#9670;&#160;</a></span>MonotonicIncreasingStack</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa38155ad9e921ee6d3cf69b328f69757">hsc_snippets::MonotonicIncreasingStack</a> = <a class="el" href="classhsc__snippets_1_1MonotonicStack.html">MonotonicStack</a>&lt;T, std::greater_equal&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a795dc74a07970f538ab222b31f874271" name="a795dc74a07970f538ab222b31f874271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795dc74a07970f538ab222b31f874271">&#9670;&#160;</a></span>additive_inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::additive_inverse </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab19a8c1f33cd0fbc24e3ea9d093430d1" name="ab19a8c1f33cd0fbc24e3ea9d093430d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19a8c1f33cd0fbc24e3ea9d093430d1">&#9670;&#160;</a></span>binary_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::integral I = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; I &gt; hsc_snippets::binary_search </td>
          <td>(</td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8052840df1ce8e295a2d69d656d836d5" name="a8052840df1ce8e295a2d69d656d836d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8052840df1ce8e295a2d69d656d836d5">&#9670;&#160;</a></span>binary_tree_to_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; hsc_snippets::binary_tree_to_adjacency_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a binary tree to an adjacency list representation. All node values in the binary tree must be unique. The adjacency list is bidirectional, meaning for each parent-child relation, both the parent's list contains the child and the child's list contains the parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the binary tree. If the tree is empty (nullptr), the function returns an empty adjacency list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered_map where keys are node values and values are vectors of integers representing the node values of adjacent nodes. </dd></dl>

</div>
</div>
<a id="aefa53f26ca29b00677b58dfbd3957fb6" name="aefa53f26ca29b00677b58dfbd3957fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa53f26ca29b00677b58dfbd3957fb6">&#9670;&#160;</a></span>breadth_first_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::breadth_first_search </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adjacency_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int, int)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a breadth-first search (BFS) on an undirected graph starting from a given root node. It uses a queue to explore nodes level by level, ensuring each node is visited exactly once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacency_list</td><td>The graph represented as an adjacency list, where each key-value pair corresponds to a node and its list of adjacent nodes. </td></tr>
    <tr><td class="paramname">root</td><td>The starting node for the BFS. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to be called for each visited node. It takes the distance from the root and the node itself as arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94bf74759d725b5eaffb0609b370eecc" name="a94bf74759d725b5eaffb0609b370eecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bf74759d725b5eaffb0609b370eecc">&#9670;&#160;</a></span>breadth_first_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::breadth_first_search </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adjacency_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int, int)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a breadth-first search (BFS) traversal on a graph represented by an adjacency list, starting from the specified root node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacency_list</td><td>The adjacency list representation of the graph. Each element represents a node and contains the indices of its adjacent nodes. </td></tr>
    <tr><td class="paramname">root</td><td>The index of the root node from which the BFS traversal starts. </td></tr>
    <tr><td class="paramname">callback</td><td>A callback function invoked for each visited node during the BFS traversal. It takes two parameters: the distance of the current node from the root and the index of the current node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f76e1d412f83567b03ef84aa374878a" name="a2f76e1d412f83567b03ef84aa374878a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f76e1d412f83567b03ef84aa374878a">&#9670;&#160;</a></span>containsInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::containsInRange </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a429782e4ffeba328dbfc0339166d667c" name="a429782e4ffeba328dbfc0339166d667c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429782e4ffeba328dbfc0339166d667c">&#9670;&#160;</a></span>delete_binary_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::delete_binary_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all nodes of a binary tree to free memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the binary tree. If the pointer is nullptr, the function does nothing, safely handling the case of an empty tree or reaching the end of a branch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85a409659bd176a384e5ebd1ec86ccb8" name="a85a409659bd176a384e5ebd1ec86ccb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a409659bd176a384e5ebd1ec86ccb8">&#9670;&#160;</a></span>depth_first_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::depth_first_search </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adjacency_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int, int)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a depth-first search (DFS) traversal on a graph represented by an adjacency list, starting from the specified root node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacency_list</td><td>The adjacency list representation of the graph. Each element represents a node and contains the indices of its adjacent nodes. </td></tr>
    <tr><td class="paramname">root</td><td>The index of the root node from which the DFS traversal starts. </td></tr>
    <tr><td class="paramname">callback</td><td>A callback function invoked for each visited node during the DFS traversal. It takes two parameters: the distance of the current node from the root and the index of the current node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9ea360ca73fc90de39097acf5adb5a8" name="ae9ea360ca73fc90de39097acf5adb5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ea360ca73fc90de39097acf5adb5a8">&#9670;&#160;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::dijkstra </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adjacency_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dijkstra's algorithm to find the shortest path from source to destination in a graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of vertices in the graph. </td></tr>
    <tr><td class="paramname">adjacency_list</td><td>Adjacency list representation of the graph where each element is a pair representing an edge (to, weight). </td></tr>
    <tr><td class="paramname">src</td><td>Source vertex. </td></tr>
    <tr><td class="paramname">dst</td><td>Destination vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shortest distance from source to destination. Returns -1 if no path exists. </dd></dl>

</div>
</div>
<a id="a50a72d9be388b969808af9cd6617aea9" name="a50a72d9be388b969808af9cd6617aea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a72d9be388b969808af9cd6617aea9">&#9670;&#160;</a></span>find_euler_path_directed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; hsc_snippets::find_euler_path_directed </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds an Eulerian path or circuit in a directed graph.</p>
<p>This function assumes that the given graph has an Eulerian path or circuit, which means the graph is connected and either: </p>
<ul>
<li>All vertices have equal in-degrees and out-degrees (Eulerian circuit), or </li>
</ul>
<ul>
<li>All but two vertices have equal in-degrees and out-degrees, and one of those two vertices has out-degree = in-degree + 1 (start), and the other has in-degree = out-degree + 1 (end) (Eulerian path).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>A vector of pairs representing directed edges in the graph. Each pair (a, b) represents a directed edge from a to b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector representing the Eulerian path or circuit as a sequence of vertex indices. If a circuit exists, the path can start from any vertex in the circuit. </dd></dl>

</div>
</div>
<a id="a16dd678bffb7adede9bc2eabe0e92665" name="a16dd678bffb7adede9bc2eabe0e92665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dd678bffb7adede9bc2eabe0e92665">&#9670;&#160;</a></span>findConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; hsc_snippets::findConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds and returns all connected components in an undirected graph. It iterates over all nodes, using a BFS starting from each unvisited node to discover all nodes in the same connected component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adj</td><td>The graph represented as an adjacency list, where keys are node identifiers and values are lists of adjacent nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors, where each inner vector represents a connected component of the graph and contains all node identifiers within that component. </dd></dl>

</div>
</div>
<a id="afff61e6f2efed27bc4bbb2a2c6a44328" name="afff61e6f2efed27bc4bbb2a2c6a44328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff61e6f2efed27bc4bbb2a2c6a44328">&#9670;&#160;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::gcd </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A numeric type that should be an integral type (e.g., int, long). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number. </td></tr>
    <tr><td class="paramname">b</td><td>The second number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest common divisor of a and b. </dd></dl>

</div>
</div>
<a id="a26cce75b709a679ebc99a4abcdbbd7bd" name="a26cce75b709a679ebc99a4abcdbbd7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cce75b709a679ebc99a4abcdbbd7bd">&#9670;&#160;</a></span>get_binary_tree_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::get_binary_tree_depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the depth of a binary tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the binary tree. If the tree is empty (nullptr), the depth is considered to be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The depth of the binary tree as an integer. An empty tree has a depth of 0. </dd></dl>

</div>
</div>
<a id="ac491df2754ee69d6ba83dfd256c3c079" name="ac491df2754ee69d6ba83dfd256c3c079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac491df2754ee69d6ba83dfd256c3c079">&#9670;&#160;</a></span>get_linked_list_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::get_linked_list_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the length of a linked list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to the head of the linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes in the linked list. </dd></dl>

</div>
</div>
<a id="a9919b9e521c5513278a973e42a1bbf42" name="a9919b9e521c5513278a973e42a1bbf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9919b9e521c5513278a973e42a1bbf42">&#9670;&#160;</a></span>greaterThanAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca360e3bd41a5aa9aa1873147e5bc823" name="aca360e3bd41a5aa9aa1873147e5bc823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca360e3bd41a5aa9aa1873147e5bc823">&#9670;&#160;</a></span>greaterThanAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21c76cdee93b66ddae3fa5a37b42f19d" name="a21c76cdee93b66ddae3fa5a37b42f19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c76cdee93b66ddae3fa5a37b42f19d">&#9670;&#160;</a></span>greaterThanOrEqualToAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae97854002bbec586ad6d0a52ab4315e3" name="ae97854002bbec586ad6d0a52ab4315e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97854002bbec586ad6d0a52ab4315e3">&#9670;&#160;</a></span>greaterThanOrEqualToAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7f93655a4a72d10c318c290783a2bdc" name="ac7f93655a4a72d10c318c290783a2bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f93655a4a72d10c318c290783a2bdc">&#9670;&#160;</a></span>greatest_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::integral I = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I hsc_snippets::greatest_index </td>
          <td>(</td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the greatest index in a non-decreasing array where the function applied to the index returns a value less than or equal to the specified value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value against which the function's results are compared. </td></tr>
    <tr><td class="paramname">I</td><td>The integral type of the index, defaulting to int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>The lower bound of the search range (inclusive). </td></tr>
    <tr><td class="paramname">high</td><td>The upper bound of the search range (inclusive). </td></tr>
    <tr><td class="paramname">value</td><td>The value to compare against the function's results. </td></tr>
    <tr><td class="paramname">func</td><td>The function to apply to each index, expected to return non-decreasing values for the range [low, high]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest index for which func(index) &lt;= value, or -1 if no such index exists. </dd></dl>

</div>
</div>
<a id="ac6c82b125272d02d5cdaa2169f225f85" name="ac6c82b125272d02d5cdaa2169f225f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c82b125272d02d5cdaa2169f225f85">&#9670;&#160;</a></span>inorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::inorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In-order traversal of a binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node of the binary tree. </td></tr>
    <tr><td class="paramname">func</td><td>Function to process each node's value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1228660ec00e385121ef6171dc80d2be" name="a1228660ec00e385121ef6171dc80d2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1228660ec00e385121ef6171dc80d2be">&#9670;&#160;</a></span>isPalindrome()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::isPalindrome </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a given string is a palindrome.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to check for palindromicity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 's' is a palindrome, False otherwise. </dd></dl>

</div>
</div>
<a id="ae063eb2bd48343750f3472eeb0320a38" name="ae063eb2bd48343750f3472eeb0320a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae063eb2bd48343750f3472eeb0320a38">&#9670;&#160;</a></span>kmpSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; hsc_snippets::kmpSearch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>txt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for all occurrences of a pattern within a text using the Knuth-Morris-Pratt (KMP) algorithm.</p>
<p>The KMP algorithm pre-processes the pattern to construct an array of longest proper prefixes which are also suffixes (LPS array). It then uses this LPS array to skip redundant comparisons when a mismatch occurs, thereby improving the search efficiency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pat</td><td>The pattern string to search for within the text. </td></tr>
    <tr><td class="paramname">txt</td><td>The text string in which to search for the pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the starting indices of all occurrences of 'pat' within 'txt'. </dd></dl>

</div>
</div>
<a id="ac9bc199445ac13f4653bf795c24cdf08" name="ac9bc199445ac13f4653bf795c24cdf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bc199445ac13f4653bf795c24cdf08">&#9670;&#160;</a></span>largestRectangleInHistogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::largestRectangleInHistogram </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>heights</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LeetCode 84: Largest Rectangle in Histogram This function calculates the maximum area of a rectangle that can be formed within a given histogram. Each bar's height is given in the 'heights' vector, where each element represents the height of a bar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heights</td><td>A vector of integers where each integer represents the height of a histogram bar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum area of the rectangle that can be formed in the histogram. </dd></dl>

</div>
</div>
<a id="a9d31a87aa5ed5297257e6daea49a4c72" name="a9d31a87aa5ed5297257e6daea49a4c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d31a87aa5ed5297257e6daea49a4c72">&#9670;&#160;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::lcm </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the least common multiple (LCM) of two numbers using the formula: LCM(a, b) = (a * b) / GCD(a, b)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A numeric type that should be an integral type (e.g., int, long). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number. </td></tr>
    <tr><td class="paramname">b</td><td>The second number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The least common multiple of a and b. </dd></dl>

</div>
</div>
<a id="ac6691641b2d50eca1b2145da55c74f1d" name="ac6691641b2d50eca1b2145da55c74f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6691641b2d50eca1b2145da55c74f1d">&#9670;&#160;</a></span>lessThanAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5c0498b1070c4404daaaf087992758b" name="ae5c0498b1070c4404daaaf087992758b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c0498b1070c4404daaaf087992758b">&#9670;&#160;</a></span>lessThanAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f9c656f40560cd6141ff708c5937b89" name="a8f9c656f40560cd6141ff708c5937b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9c656f40560cd6141ff708c5937b89">&#9670;&#160;</a></span>lessThanOrEqualToAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e874c9c2bfef67800a520d9ccf60805" name="a0e874c9c2bfef67800a520d9ccf60805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e874c9c2bfef67800a520d9ccf60805">&#9670;&#160;</a></span>lessThanOrEqualToAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad242c8792daef6564483babc4db2e7ca" name="ad242c8792daef6564483babc4db2e7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad242c8792daef6564483babc4db2e7ca">&#9670;&#160;</a></span>linked_list_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::linked_list_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all nodes in a linked list to free memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to the head of the linked list to be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40cb53700e41ce0806b784d51afe7aaa" name="a40cb53700e41ce0806b784d51afe7aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cb53700e41ce0806b784d51afe7aaa">&#9670;&#160;</a></span>linked_list_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> * hsc_snippets::linked_list_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes nodes from a linked list in the specified range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list. </td></tr>
    <tr><td class="paramname">begin</td><td>The starting index of the range to remove nodes (inclusive). </td></tr>
    <tr><td class="paramname">end</td><td>The ending index of the range to remove nodes (exclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the head of the modified linked list. </dd></dl>

</div>
</div>
<a id="a753a3ebbdd118444fed6c922d57de01f" name="a753a3ebbdd118444fed6c922d57de01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753a3ebbdd118444fed6c922d57de01f">&#9670;&#160;</a></span>linked_list_to_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; hsc_snippets::linked_list_to_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a linked list to a vector of integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to the head of the linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of integers containing the values of the linked list nodes. </dd></dl>

</div>
</div>
<a id="a1d00610b7e210a53730c9ffdfeba57b9" name="a1d00610b7e210a53730c9ffdfeba57b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d00610b7e210a53730c9ffdfeba57b9">&#9670;&#160;</a></span>make_linked_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> * hsc_snippets::make_linked_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a linked list from a vector of integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A reference to a vector of integers from which to create the linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the head of the newly created linked list. </dd></dl>

</div>
</div>
<a id="aa00180746e48d290f32ebbbeb663a3aa" name="aa00180746e48d290f32ebbbeb663a3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00180746e48d290f32ebbbeb663a3aa">&#9670;&#160;</a></span>make_unweighted_directed_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; hsc_snippets::make_unweighted_directed_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an unweighted, directed adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains two integers: [from, to], denoting a directed edge from node 'from' to node 'to'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors representing the adjacency list of the graph. Each inner vector corresponds to a node, containing the indices of connected nodes (edges are unweighted in this representation). </dd></dl>

</div>
</div>
<a id="a6652ea3101ac6cfdad917c467930b521" name="a6652ea3101ac6cfdad917c467930b521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6652ea3101ac6cfdad917c467930b521">&#9670;&#160;</a></span>make_unweighted_undirected_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; hsc_snippets::make_unweighted_undirected_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an unweighted, undirected adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains two integers: [from, to], denoting an edge from node 'from' to node 'to'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors representing the adjacency list of the graph. Each inner vector corresponds to a node, containing the indices of connected nodes (edges are unweighted in this representation). </dd></dl>

</div>
</div>
<a id="a3309599331a5cdd33769faddfefca01b" name="a3309599331a5cdd33769faddfefca01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3309599331a5cdd33769faddfefca01b">&#9670;&#160;</a></span>make_weighted_directed_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt; hsc_snippets::make_weighted_directed_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a weighted, directed adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains three integers: [from, to, weight], denoting a weighted edge from node 'from' to node 'to' with the given weight. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors of pairs representing the adjacency list of the graph. Each inner vector corresponds to a node, containing pairs of connected nodes and their respective edge weights. </dd></dl>

</div>
</div>
<a id="a6d8cb2639fba615716c6ce0717de2e9e" name="a6d8cb2639fba615716c6ce0717de2e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8cb2639fba615716c6ce0717de2e9e">&#9670;&#160;</a></span>make_weighted_undirected_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt; hsc_snippets::make_weighted_undirected_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a weighted, undirected adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains three integers: [from, to, weight], denoting a weighted edge between node 'from' and node 'to' with the given weight. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors of pairs representing the adjacency list of the graph. Each inner vector corresponds to a node, containing pairs of connected nodes and their respective edge weights. </dd></dl>

</div>
</div>
<a id="a7c058184d3bf4b4028ac27888f891666" name="a7c058184d3bf4b4028ac27888f891666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c058184d3bf4b4028ac27888f891666">&#9670;&#160;</a></span>modular_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_add </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a69f0c52364cd0e82d19151f1d05aee8c" name="a69f0c52364cd0e82d19151f1d05aee8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f0c52364cd0e82d19151f1d05aee8c">&#9670;&#160;</a></span>modular_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_cube </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36dc1f9c8622b338e040c3d0746ffa45" name="a36dc1f9c8622b338e040c3d0746ffa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36dc1f9c8622b338e040c3d0746ffa45">&#9670;&#160;</a></span>modular_multiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_multiply </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72561173b55e31dc534d5f5612a52246" name="a72561173b55e31dc534d5f5612a52246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72561173b55e31dc534d5f5612a52246">&#9670;&#160;</a></span>modular_pow2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_pow2 </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab24c9c4d4245ec401fd40ecb1a12c1b6" name="ab24c9c4d4245ec401fd40ecb1a12c1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24c9c4d4245ec401fd40ecb1a12c1b6">&#9670;&#160;</a></span>modular_square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_square </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5b88bd1961aeceb11486a737609e862" name="af5b88bd1961aeceb11486a737609e862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b88bd1961aeceb11486a737609e862">&#9670;&#160;</a></span>modular_substract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_substract </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d713b7bb2ef09fac4d0b640185b52b4" name="a2d713b7bb2ef09fac4d0b640185b52b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d713b7bb2ef09fac4d0b640185b52b4">&#9670;&#160;</a></span>new_binary_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> * hsc_snippets::new_binary_tree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::optional&lt; int &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a binary tree from a vector of optional integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A vector of std::optional&lt;int&gt;, where each element represents a potential node in the binary tree. An std::nullopt value indicates the absence of a node at that position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the root node of the newly constructed binary tree. Returns nullptr if the input vector is empty. </dd></dl>

</div>
</div>
<a id="a58ccbeb569860677c784f504351db1d8" name="a58ccbeb569860677c784f504351db1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ccbeb569860677c784f504351db1d8">&#9670;&#160;</a></span>nextGreaterElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; hsc_snippets::nextGreaterElement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nums</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; T()&gt;</td>          <td class="paramname"><span class="paramname"><em>no_greater</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the next greater element for each element in a sequence. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements in the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nums</td><td>The sequence of elements. </td></tr>
    <tr><td class="paramname">no_greater</td><td>Function to call when no greater element is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the next greater element for each element in <code>nums</code>. </dd></dl>

</div>
</div>
<a id="a9dc8f948cda1de6cbdb67bf6680d87f9" name="a9dc8f948cda1de6cbdb67bf6680d87f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc8f948cda1de6cbdb67bf6680d87f9">&#9670;&#160;</a></span>numBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::numBits </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of bits required to represent an integer in binary. For negative numbers, it returns the number of bits in the type (e.g., 32 for int), assuming two's complement representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the input number, constrained to integral types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The input number whose binary bit count is to be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bits required to represent num in binary, or the bit size of T for negative numbers. </dd></dl>

</div>
</div>
<a id="a21faa054d1afffbd2d869a99a54209de" name="a21faa054d1afffbd2d869a99a54209de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21faa054d1afffbd2d869a99a54209de">&#9670;&#160;</a></span>numDigits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::numDigits </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of digits in the decimal representation of an integer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the input number, constrained to integral types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The input number whose number of decimal digits is to be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of digits in the decimal representation of num. </dd></dl>

</div>
</div>
<a id="a770cc063eb04b7231b755c72383511d3" name="a770cc063eb04b7231b755c72383511d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770cc063eb04b7231b755c72383511d3">&#9670;&#160;</a></span>numOfGreaterElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::totally_ordered T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::numOfGreaterElements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a434872c7db853da32dcaf6254abf53bd" name="a434872c7db853da32dcaf6254abf53bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434872c7db853da32dcaf6254abf53bd">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hsc_snippets::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>interval</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad46c82943972e1cda8e400b287ca10e4" name="ad46c82943972e1cda8e400b287ca10e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46c82943972e1cda8e400b287ca10e4">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hsc_snippets::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>interval1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>interval2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4893ca5a1d94f3b1c7ed3768bb4c3a3a" name="a4893ca5a1d94f3b1c7ed3768bb4c3a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4893ca5a1d94f3b1c7ed3768bb4c3a3a">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hsc_snippets::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>interval</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f8f2987db631e9af726376704c355b8" name="a6f8f2987db631e9af726376704c355b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8f2987db631e9af726376704c355b8">&#9670;&#160;</a></span>postorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::postorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Post-order traversal of a binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node of the binary tree. </td></tr>
    <tr><td class="paramname">func</td><td>Function to process each node's value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32df3d871f5bcd99ec98038fe7d7ae02" name="a32df3d871f5bcd99ec98038fe7d7ae02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32df3d871f5bcd99ec98038fe7d7ae02">&#9670;&#160;</a></span>preorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::preorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pre-order traversal of a binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node of the binary tree. </td></tr>
    <tr><td class="paramname">func</td><td>Function to process each node's value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18d5f09b15d654e057d86fee902cab7d" name="a18d5f09b15d654e057d86fee902cab7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d5f09b15d654e057d86fee902cab7d">&#9670;&#160;</a></span>SieveOfEratosthenes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; hsc_snippets::SieveOfEratosthenes </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements the Sieve of Eratosthenes algorithm to find all prime numbers up to a given limit n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The upper limit (inclusive) up to which prime numbers are to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;int&gt; containing all the prime numbers less than or equal to n. </dd></dl>

</div>
</div>
<a id="a8b3d0574aec6857720f3494a33cc7a85" name="a8b3d0574aec6857720f3494a33cc7a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3d0574aec6857720f3494a33cc7a85">&#9670;&#160;</a></span>smallest_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::integral I = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I hsc_snippets::smallest_index </td>
          <td>(</td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the smallest index in a non-decreasing array where the function applied to the index returns a value greater than or equal to the specified value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value against which the function's results are compared. </td></tr>
    <tr><td class="paramname">I</td><td>The integral type of the index, defaulting to int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>The lower bound of the search range (inclusive). </td></tr>
    <tr><td class="paramname">high</td><td>The upper bound of the search range (inclusive). </td></tr>
    <tr><td class="paramname">value</td><td>The value to compare against the function's results. </td></tr>
    <tr><td class="paramname">func</td><td>The function to apply to each index, expected to return non-decreasing values for the range [low, high]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest index for which func(index) &gt;= value, or -1 if no such index exists. </dd></dl>

</div>
</div>
<a id="adbdb05e51cc5a1ab1a9b3aea8075b2ef" name="adbdb05e51cc5a1ab1a9b3aea8075b2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdb05e51cc5a1ab1a9b3aea8075b2ef">&#9670;&#160;</a></span>sortThree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::sortThree </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts three elements in non-decreasing order using a simple comparison and swap algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements to be sorted. Must be an integral type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Reference to the first element, will be the smallest after sorting. </td></tr>
    <tr><td class="paramname">b</td><td>Reference to the second element, will be the middle element after sorting. </td></tr>
    <tr><td class="paramname">c</td><td>Reference to the third element, will be the largest after sorting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57bc4b2d7435fc0d95a1faa768e08797" name="a57bc4b2d7435fc0d95a1faa768e08797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bc4b2d7435fc0d95a1faa768e08797">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; hsc_snippets::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits a given string into a vector of substrings based on a specified delimiter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The input string to be split. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character used as the delimiter to split the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of substrings obtained by splitting the input string by the delimiter. </dd></dl>

</div>
</div>
<a id="a97059b7ec97027b3b47ca79786b8704f" name="a97059b7ec97027b3b47ca79786b8704f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97059b7ec97027b3b47ca79786b8704f">&#9670;&#160;</a></span>subarraysWithAtMostKDistinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::subarraysWithAtMostKDistinct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nums</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts subarrays with at most <code>k</code> distinct integers using a sliding window approach.</p>
<p>Related LeetCode Problem: <a href="https://leetcode.com/problems/subarrays-with-k-different-integers/description/">https://leetcode.com/problems/subarrays-with-k-different-integers/description/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nums</td><td>A vector of integers. </td></tr>
    <tr><td class="paramname">k</td><td>The maximum number of distinct integers allowed in a subarray. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total count of such subarrays. </dd></dl>

</div>
</div>
<a id="a3e6dae9bb445381d5ec6a88094c9f315" name="a3e6dae9bb445381d5ec6a88094c9f315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6dae9bb445381d5ec6a88094c9f315">&#9670;&#160;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::sum </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adabb6992d6adc87e88949774ea718c67" name="adabb6992d6adc87e88949774ea718c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabb6992d6adc87e88949774ea718c67">&#9670;&#160;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::sum </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99ec3e40e27b79ffc33545635fba4503" name="a99ec3e40e27b79ffc33545635fba4503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ec3e40e27b79ffc33545635fba4503">&#9670;&#160;</a></span>to_string() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a vector of pairs of integral type T to its string representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of the elements in the pairs within the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of pairs to convert to a string representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the vector of pairs, formatted as "[{first1, second1}, {first2, second2}, ...]". </dd></dl>

</div>
</div>
<a id="a64970a5102d416fdd499f71c3cd1000f" name="a64970a5102d416fdd499f71c3cd1000f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64970a5102d416fdd499f71c3cd1000f">&#9670;&#160;</a></span>to_string() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a vector of strings to its string representation, with elements separated by commas. The resulting string is enclosed in square brackets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of strings to convert. Each element in the vector is expected to be a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the vector's contents, formatted as "[element1, element2, ...]". If the vector is empty, the returned string will be "[]". </dd></dl>

</div>
</div>
<a id="a611d2268215b58fd16cde84613d4fc6b" name="a611d2268215b58fd16cde84613d4fc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611d2268215b58fd16cde84613d4fc6b">&#9670;&#160;</a></span>to_string() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a vector of vectors of integral type T to its string representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of elements in the vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of vectors to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the vector of vectors. </dd></dl>

</div>
</div>
<a id="aea5a6b2a2e32759546fc105652ee34c6" name="aea5a6b2a2e32759546fc105652ee34c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5a6b2a2e32759546fc105652ee34c6">&#9670;&#160;</a></span>to_string() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a vector of integral type T to its string representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of elements in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the vector. </dd></dl>

</div>
</div>
<a id="aa6c60972c6e940cc87036321ae5c5136" name="aa6c60972c6e940cc87036321ae5c5136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c60972c6e940cc87036321ae5c5136">&#9670;&#160;</a></span>to_string() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; T, T &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a pair of integral type T to its string representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of the pair elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pair to convert to a string representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the pair, formatted as "{first, second}". </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a218d0181825bcf526ca9e5c24f6aab06" name="a218d0181825bcf526ca9e5c24f6aab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218d0181825bcf526ca9e5c24f6aab06">&#9670;&#160;</a></span>MODULO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::MODULO = static_cast&lt;int&gt;(1e9 + 7)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
