<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>snippets: hsc_snippets Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">snippets<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">hsc_snippets Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1BigInteger.html">BigInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a class for representing and manipulating large integers beyond the native integer range.  <a href="classhsc__snippets_1_1BigInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1DisjointSet.html">DisjointSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1DominantTracker.html">DominantTracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1IntervalMap.html">IntervalMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1IntervalSet.html">IntervalSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1Maximum.html">Maximum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1MonotonicStack.html">MonotonicStack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1Override.html">Override</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1SegmentTree.html">SegmentTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1SlidingWindowMax.html">SlidingWindowMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concepthsc__snippets_1_1numeric.html">numeric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9cbfd0b02206d45ef53cae53da08bde1" id="r_a9cbfd0b02206d45ef53cae53da08bde1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9cbfd0b02206d45ef53cae53da08bde1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9cbfd0b02206d45ef53cae53da08bde1">MonotonicDecreasingStack</a> = <a class="el" href="classhsc__snippets_1_1MonotonicStack.html">MonotonicStack</a>&lt;T, std::less_equal&lt;T&gt;&gt;</td></tr>
<tr class="separator:a9cbfd0b02206d45ef53cae53da08bde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38155ad9e921ee6d3cf69b328f69757" id="r_aa38155ad9e921ee6d3cf69b328f69757"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa38155ad9e921ee6d3cf69b328f69757"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa38155ad9e921ee6d3cf69b328f69757">MonotonicIncreasingStack</a> = <a class="el" href="classhsc__snippets_1_1MonotonicStack.html">MonotonicStack</a>&lt;T, std::greater_equal&lt;T&gt;&gt;</td></tr>
<tr class="separator:aa38155ad9e921ee6d3cf69b328f69757"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a136d6a09342381325d92a6c9d17a3fac" id="r_a136d6a09342381325d92a6c9d17a3fac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a136d6a09342381325d92a6c9d17a3fac">new_binary_tree</a> (const std::vector&lt; std::optional&lt; int &gt; &gt; v)</td></tr>
<tr class="separator:a136d6a09342381325d92a6c9d17a3fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89532c357a8e55dfcdd9b748c39ca1c" id="r_af89532c357a8e55dfcdd9b748c39ca1c"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::optional&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af89532c357a8e55dfcdd9b748c39ca1c">binary_tree_to_vector</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root)</td></tr>
<tr class="separator:af89532c357a8e55dfcdd9b748c39ca1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3d7e58268e86266dfc92d8c0518707" id="r_a0e3d7e58268e86266dfc92d8c0518707"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e3d7e58268e86266dfc92d8c0518707">delete_binary_tree</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root)</td></tr>
<tr class="separator:a0e3d7e58268e86266dfc92d8c0518707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d508b22e8ae3deb4ae7b5f75e968f3" id="r_a41d508b22e8ae3deb4ae7b5f75e968f3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41d508b22e8ae3deb4ae7b5f75e968f3">get_binary_tree_depth</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root)</td></tr>
<tr class="separator:a41d508b22e8ae3deb4ae7b5f75e968f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb08fb820f5c795965a4f91467c91f3f" id="r_abb08fb820f5c795965a4f91467c91f3f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb08fb820f5c795965a4f91467c91f3f">inorder</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root, std::function&lt; void(int)&gt; func)</td></tr>
<tr class="separator:abb08fb820f5c795965a4f91467c91f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634fab7f601ccfc94bf4a3c1d60332fe" id="r_a634fab7f601ccfc94bf4a3c1d60332fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a634fab7f601ccfc94bf4a3c1d60332fe">preorder</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root, std::function&lt; void(int)&gt; func)</td></tr>
<tr class="separator:a634fab7f601ccfc94bf4a3c1d60332fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1a49963ffe7f4d3761fb9b13145092" id="r_a7a1a49963ffe7f4d3761fb9b13145092"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a1a49963ffe7f4d3761fb9b13145092">postorder</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root, std::function&lt; void(int)&gt; func)</td></tr>
<tr class="separator:a7a1a49963ffe7f4d3761fb9b13145092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac879e738d6cc7459cdc04fbc7e60d017" id="r_ac879e738d6cc7459cdc04fbc7e60d017"><td class="memItemLeft" align="right" valign="top">static std::unordered_map&lt; int, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac879e738d6cc7459cdc04fbc7e60d017">binary_tree_to_adjacency_list</a> (<a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *root)</td></tr>
<tr class="separator:ac879e738d6cc7459cdc04fbc7e60d017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ea5ef53cab9fb29f63a5951becb70e" id="r_a58ea5ef53cab9fb29f63a5951becb70e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58ea5ef53cab9fb29f63a5951becb70e">make_weighted_directed_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:a58ea5ef53cab9fb29f63a5951becb70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c27454d2b8c5a9c354da37c60ada0f" id="r_af6c27454d2b8c5a9c354da37c60ada0f"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6c27454d2b8c5a9c354da37c60ada0f">make_unweighted_undirected_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:af6c27454d2b8c5a9c354da37c60ada0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec6e85a62b0f66d37d62604c0088c37" id="r_a6ec6e85a62b0f66d37d62604c0088c37"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ec6e85a62b0f66d37d62604c0088c37">make_weighted_undirected_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:a6ec6e85a62b0f66d37d62604c0088c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3384a2049e5e30e2b4aa10550175daa6" id="r_a3384a2049e5e30e2b4aa10550175daa6"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3384a2049e5e30e2b4aa10550175daa6">make_unweighted_directed_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:a3384a2049e5e30e2b4aa10550175daa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c5d7cb8bacbba1f47c93754aa41dcf" id="r_ae6c5d7cb8bacbba1f47c93754aa41dcf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6c5d7cb8bacbba1f47c93754aa41dcf">breadth_first_search</a> (std::vector&lt; std::vector&lt; int &gt; &gt; &amp;adjacency_list, int root, std::function&lt; void(int, int)&gt; callback)</td></tr>
<tr class="separator:ae6c5d7cb8bacbba1f47c93754aa41dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1ec5bec1478c4c998682cc18f206ef" id="r_a3b1ec5bec1478c4c998682cc18f206ef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1ec5bec1478c4c998682cc18f206ef">breadth_first_search</a> (std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; &amp;adjacency_list, int root, std::function&lt; void(int, int)&gt; callback)</td></tr>
<tr class="separator:a3b1ec5bec1478c4c998682cc18f206ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7d53ab011791a0531e5bcd779f3793" id="r_a8d7d53ab011791a0531e5bcd779f3793"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d7d53ab011791a0531e5bcd779f3793">depth_first_search</a> (std::vector&lt; std::vector&lt; int &gt; &gt; &amp;adjacency_list, int root, std::function&lt; void(int, int)&gt; callback)</td></tr>
<tr class="separator:a8d7d53ab011791a0531e5bcd779f3793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000828beeb1f7645e3c72a63c7b7fa92" id="r_a000828beeb1f7645e3c72a63c7b7fa92"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a000828beeb1f7645e3c72a63c7b7fa92">dijkstra</a> (int n, const std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt; &amp;adjacency_list, int src, int dst)</td></tr>
<tr class="separator:a000828beeb1f7645e3c72a63c7b7fa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0021648770f8ed93a2d6e0fb224894e" id="r_ac0021648770f8ed93a2d6e0fb224894e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0021648770f8ed93a2d6e0fb224894e">find_euler_path_directed</a> (const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:ac0021648770f8ed93a2d6e0fb224894e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158980980e40006ca0b81338ad6c0408" id="r_a158980980e40006ca0b81338ad6c0408"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a158980980e40006ca0b81338ad6c0408">find_connected_components</a> (std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; &amp;adj)</td></tr>
<tr class="separator:a158980980e40006ca0b81338ad6c0408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf59f1c3888dcf2c9ecf14bdb9a4f80" id="r_a7bf59f1c3888dcf2c9ecf14bdb9a4f80"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bf59f1c3888dcf2c9ecf14bdb9a4f80">count_connected_components</a> (const std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; &amp;adj)</td></tr>
<tr class="separator:a7bf59f1c3888dcf2c9ecf14bdb9a4f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434872c7db853da32dcaf6254abf53bd" id="r_a434872c7db853da32dcaf6254abf53bd"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a434872c7db853da32dcaf6254abf53bd"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a434872c7db853da32dcaf6254abf53bd">operator&lt;</a> (const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;interval, T x)</td></tr>
<tr class="separator:a434872c7db853da32dcaf6254abf53bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4893ca5a1d94f3b1c7ed3768bb4c3a3a" id="r_a4893ca5a1d94f3b1c7ed3768bb4c3a3a"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a4893ca5a1d94f3b1c7ed3768bb4c3a3a"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4893ca5a1d94f3b1c7ed3768bb4c3a3a">operator&lt;</a> (T x, const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;interval)</td></tr>
<tr class="separator:a4893ca5a1d94f3b1c7ed3768bb4c3a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46c82943972e1cda8e400b287ca10e4" id="r_ad46c82943972e1cda8e400b287ca10e4"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:ad46c82943972e1cda8e400b287ca10e4"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad46c82943972e1cda8e400b287ca10e4">operator&lt;</a> (const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;interval1, const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;interval2)</td></tr>
<tr class="separator:ad46c82943972e1cda8e400b287ca10e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55a2dd20854e1a9cb1b397d7368ee1c" id="r_aa55a2dd20854e1a9cb1b397d7368ee1c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa55a2dd20854e1a9cb1b397d7368ee1c">get_linked_list_length</a> (<a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *head)</td></tr>
<tr class="separator:aa55a2dd20854e1a9cb1b397d7368ee1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6a5ac55d0bc6bbef668820bd517111" id="r_a5b6a5ac55d0bc6bbef668820bd517111"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b6a5ac55d0bc6bbef668820bd517111">make_linked_list</a> (const std::vector&lt; int &gt; &amp;v)</td></tr>
<tr class="separator:a5b6a5ac55d0bc6bbef668820bd517111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad15a7a05a44dbdde22dd2a4bb4327f" id="r_afad15a7a05a44dbdde22dd2a4bb4327f"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afad15a7a05a44dbdde22dd2a4bb4327f">linked_list_to_vector</a> (<a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *head)</td></tr>
<tr class="separator:afad15a7a05a44dbdde22dd2a4bb4327f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a04f3114efd0152b433b11da85238e" id="r_a00a04f3114efd0152b433b11da85238e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00a04f3114efd0152b433b11da85238e">linked_list_delete</a> (<a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *head)</td></tr>
<tr class="separator:a00a04f3114efd0152b433b11da85238e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7f423ee4b9024557d8497b2c46755d" id="r_a0c7f423ee4b9024557d8497b2c46755d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c7f423ee4b9024557d8497b2c46755d">linked_list_remove</a> (<a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *head, size_t begin, size_t end)</td></tr>
<tr class="separator:a0c7f423ee4b9024557d8497b2c46755d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c058184d3bf4b4028ac27888f891666" id="r_a7c058184d3bf4b4028ac27888f891666"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c058184d3bf4b4028ac27888f891666">modular_add</a> (int x, int y)</td></tr>
<tr class="separator:a7c058184d3bf4b4028ac27888f891666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795dc74a07970f538ab222b31f874271" id="r_a795dc74a07970f538ab222b31f874271"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a795dc74a07970f538ab222b31f874271">additive_inverse</a> (int x)</td></tr>
<tr class="separator:a795dc74a07970f538ab222b31f874271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b713f9ee2ad0ce059e4f017d5e3e87" id="r_a07b713f9ee2ad0ce059e4f017d5e3e87"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07b713f9ee2ad0ce059e4f017d5e3e87">modular_subtract</a> (int x, int y)</td></tr>
<tr class="separator:a07b713f9ee2ad0ce059e4f017d5e3e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dc1f9c8622b338e040c3d0746ffa45" id="r_a36dc1f9c8622b338e040c3d0746ffa45"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36dc1f9c8622b338e040c3d0746ffa45">modular_multiply</a> (int x, int y)</td></tr>
<tr class="separator:a36dc1f9c8622b338e040c3d0746ffa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24c9c4d4245ec401fd40ecb1a12c1b6" id="r_ab24c9c4d4245ec401fd40ecb1a12c1b6"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab24c9c4d4245ec401fd40ecb1a12c1b6">modular_square</a> (int x)</td></tr>
<tr class="separator:ab24c9c4d4245ec401fd40ecb1a12c1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f0c52364cd0e82d19151f1d05aee8c" id="r_a69f0c52364cd0e82d19151f1d05aee8c"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69f0c52364cd0e82d19151f1d05aee8c">modular_cube</a> (int x)</td></tr>
<tr class="separator:a69f0c52364cd0e82d19151f1d05aee8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8614f9b32030042e88023008f23a68e1" id="r_a8614f9b32030042e88023008f23a68e1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8614f9b32030042e88023008f23a68e1">modular_pow2</a> (size_t exponent)</td></tr>
<tr class="separator:a8614f9b32030042e88023008f23a68e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ccbeb569860677c784f504351db1d8" id="r_a58ccbeb569860677c784f504351db1d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58ccbeb569860677c784f504351db1d8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58ccbeb569860677c784f504351db1d8">nextGreaterElement</a> (const std::vector&lt; T &gt; &amp;nums, std::function&lt; T()&gt; no_greater)</td></tr>
<tr class="separator:a58ccbeb569860677c784f504351db1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c5f4718fb5c5d24e6b7ef9f1ede860" id="r_af1c5f4718fb5c5d24e6b7ef9f1ede860"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1c5f4718fb5c5d24e6b7ef9f1ede860">largestRectangleInHistogram</a> (const std::vector&lt; int &gt; &amp;heights)</td></tr>
<tr class="separator:af1c5f4718fb5c5d24e6b7ef9f1ede860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21faa054d1afffbd2d869a99a54209de" id="r_a21faa054d1afffbd2d869a99a54209de"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a21faa054d1afffbd2d869a99a54209de"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21faa054d1afffbd2d869a99a54209de">numDigits</a> (T num)</td></tr>
<tr class="separator:a21faa054d1afffbd2d869a99a54209de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc8f948cda1de6cbdb67bf6680d87f9" id="r_a9dc8f948cda1de6cbdb67bf6680d87f9"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a9dc8f948cda1de6cbdb67bf6680d87f9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9dc8f948cda1de6cbdb67bf6680d87f9">numBits</a> (T num)</td></tr>
<tr class="separator:a9dc8f948cda1de6cbdb67bf6680d87f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff61e6f2efed27bc4bbb2a2c6a44328" id="r_afff61e6f2efed27bc4bbb2a2c6a44328"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:afff61e6f2efed27bc4bbb2a2c6a44328"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afff61e6f2efed27bc4bbb2a2c6a44328">gcd</a> (T a, T b)</td></tr>
<tr class="separator:afff61e6f2efed27bc4bbb2a2c6a44328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d31a87aa5ed5297257e6daea49a4c72" id="r_a9d31a87aa5ed5297257e6daea49a4c72"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a9d31a87aa5ed5297257e6daea49a4c72"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d31a87aa5ed5297257e6daea49a4c72">lcm</a> (T a, T b)</td></tr>
<tr class="separator:a9d31a87aa5ed5297257e6daea49a4c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63947c3cdde506a8b9d7c658b77c9ce3" id="r_a63947c3cdde506a8b9d7c658b77c9ce3"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63947c3cdde506a8b9d7c658b77c9ce3">SieveOfEratosthenes</a> (int n)</td></tr>
<tr class="separator:a63947c3cdde506a8b9d7c658b77c9ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca516ac018a2770d79d6fe162f497d1" id="r_a7ca516ac018a2770d79d6fe162f497d1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ca516ac018a2770d79d6fe162f497d1">isPerfectSquare</a> (std::int32_t num)</td></tr>
<tr class="separator:a7ca516ac018a2770d79d6fe162f497d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ce4368d4f4c5ca1ab4959cd68c95b6" id="r_a99ce4368d4f4c5ca1ab4959cd68c95b6"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a99ce4368d4f4c5ca1ab4959cd68c95b6"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99ce4368d4f4c5ca1ab4959cd68c95b6">getPrefixMax</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a99ce4368d4f4c5ca1ab4959cd68c95b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the prefix maximums of a given vector.  <br /></td></tr>
<tr class="separator:a99ce4368d4f4c5ca1ab4959cd68c95b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d62a802305764f19b2a54a23404d1b6" id="r_a5d62a802305764f19b2a54a23404d1b6"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a5d62a802305764f19b2a54a23404d1b6"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d62a802305764f19b2a54a23404d1b6">getSuffixMax</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a5d62a802305764f19b2a54a23404d1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the suffix maximums of a given vector.  <br /></td></tr>
<tr class="separator:a5d62a802305764f19b2a54a23404d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d8767443119ae94d6401e750df49d4" id="r_a96d8767443119ae94d6401e750df49d4"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a96d8767443119ae94d6401e750df49d4"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a96d8767443119ae94d6401e750df49d4">getPrefixMin</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a96d8767443119ae94d6401e750df49d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the prefix minimums of a given vector.  <br /></td></tr>
<tr class="separator:a96d8767443119ae94d6401e750df49d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c06b519aff691bfd054ba9bb3c1ef3" id="r_a33c06b519aff691bfd054ba9bb3c1ef3"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a33c06b519aff691bfd054ba9bb3c1ef3"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a33c06b519aff691bfd054ba9bb3c1ef3">getSuffixMin</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a33c06b519aff691bfd054ba9bb3c1ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the suffix minimums of a given vector.  <br /></td></tr>
<tr class="separator:a33c06b519aff691bfd054ba9bb3c1ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d6c4d4f4ddd13119de137ddcef7d46" id="r_ac3d6c4d4f4ddd13119de137ddcef7d46"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:ac3d6c4d4f4ddd13119de137ddcef7d46"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3d6c4d4f4ddd13119de137ddcef7d46">getPrefixSum</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ac3d6c4d4f4ddd13119de137ddcef7d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the prefix sums of a given vector.  <br /></td></tr>
<tr class="separator:ac3d6c4d4f4ddd13119de137ddcef7d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201f499f92fb7f8d6bc0994f12787d3f" id="r_a201f499f92fb7f8d6bc0994f12787d3f"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a201f499f92fb7f8d6bc0994f12787d3f"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a201f499f92fb7f8d6bc0994f12787d3f">getSuffixSum</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a201f499f92fb7f8d6bc0994f12787d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the suffix sums of a given vector.  <br /></td></tr>
<tr class="separator:a201f499f92fb7f8d6bc0994f12787d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab5e0be351fbd951110f389d9bc1914" id="r_afab5e0be351fbd951110f389d9bc1914"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afab5e0be351fbd951110f389d9bc1914">subarraysWithAtMostKDistinct</a> (const std::vector&lt; int &gt; &amp;nums, int k)</td></tr>
<tr class="separator:afab5e0be351fbd951110f389d9bc1914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770cc063eb04b7231b755c72383511d3" id="r_a770cc063eb04b7231b755c72383511d3"><td class="memTemplParams" colspan="2">template&lt;std::totally_ordered T&gt; </td></tr>
<tr class="memitem:a770cc063eb04b7231b755c72383511d3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a770cc063eb04b7231b755c72383511d3">numOfGreaterElements</a> (const std::vector&lt; T &gt; &amp;v, T value)</td></tr>
<tr class="separator:a770cc063eb04b7231b755c72383511d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f76e1d412f83567b03ef84aa374878a" id="r_a2f76e1d412f83567b03ef84aa374878a"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a2f76e1d412f83567b03ef84aa374878a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2f76e1d412f83567b03ef84aa374878a">containsInRange</a> (const std::vector&lt; T &gt; &amp;vec, T start, T end)</td></tr>
<tr class="separator:a2f76e1d412f83567b03ef84aa374878a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02082c12d950f24bf7fce02f3b297f56" id="r_a02082c12d950f24bf7fce02f3b297f56"><td class="memTemplParams" colspan="2">template&lt;typename T , std::integral I = int&gt; </td></tr>
<tr class="memitem:a02082c12d950f24bf7fce02f3b297f56"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a02082c12d950f24bf7fce02f3b297f56">deferred_binary_search</a> (I low, I high, const T &amp;value, auto &amp;&amp;func)</td></tr>
<tr class="separator:a02082c12d950f24bf7fce02f3b297f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36174f67e1f87d9f5a216eb4d89fa48f" id="r_a36174f67e1f87d9f5a216eb4d89fa48f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::integral I = int&gt; </td></tr>
<tr class="memitem:a36174f67e1f87d9f5a216eb4d89fa48f"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a36174f67e1f87d9f5a216eb4d89fa48f">deferred_upper_bound</a> (I low, I high, const T &amp;value, auto &amp;&amp;func, auto &amp;&amp;comp)</td></tr>
<tr class="separator:a36174f67e1f87d9f5a216eb4d89fa48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092b51d2598ce4226eb601e044152bc8" id="r_a092b51d2598ce4226eb601e044152bc8"><td class="memTemplParams" colspan="2">template&lt;typename T , std::integral I = int&gt; </td></tr>
<tr class="memitem:a092b51d2598ce4226eb601e044152bc8"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a092b51d2598ce4226eb601e044152bc8">deferred_upper_bound</a> (I low, I high, const T &amp;value, auto &amp;&amp;func)</td></tr>
<tr class="separator:a092b51d2598ce4226eb601e044152bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecad31f49f44ade0971cb68062a4044d" id="r_aecad31f49f44ade0971cb68062a4044d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::integral I = int&gt; </td></tr>
<tr class="memitem:aecad31f49f44ade0971cb68062a4044d"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aecad31f49f44ade0971cb68062a4044d">deferred_lower_bound</a> (I low, I high, const T &amp;value, auto &amp;&amp;func, auto &amp;&amp;comp)</td></tr>
<tr class="separator:aecad31f49f44ade0971cb68062a4044d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9020303fa26c0f607fcb4059d0e919cf" id="r_a9020303fa26c0f607fcb4059d0e919cf"><td class="memTemplParams" colspan="2">template&lt;typename T , std::integral I = int&gt; </td></tr>
<tr class="memitem:a9020303fa26c0f607fcb4059d0e919cf"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9020303fa26c0f607fcb4059d0e919cf">deferred_lower_bound</a> (I low, I high, const T &amp;value, auto &amp;&amp;func)</td></tr>
<tr class="separator:a9020303fa26c0f607fcb4059d0e919cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdb05e51cc5a1ab1a9b3aea8075b2ef" id="r_adbdb05e51cc5a1ab1a9b3aea8075b2ef"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:adbdb05e51cc5a1ab1a9b3aea8075b2ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbdb05e51cc5a1ab1a9b3aea8075b2ef">sortThree</a> (T &amp;a, T &amp;b, T &amp;c)</td></tr>
<tr class="separator:adbdb05e51cc5a1ab1a9b3aea8075b2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dc9e7e53c53953a643e245a3419124" id="r_a19dc9e7e53c53953a643e245a3419124"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; std::function&lt; int(int)&gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19dc9e7e53c53953a643e245a3419124">create_compression_mapper</a> (const std::vector&lt; int &gt; &amp;nums)</td></tr>
<tr class="separator:a19dc9e7e53c53953a643e245a3419124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bd04e06f2b1c247c71d817cb114382" id="r_ab6bd04e06f2b1c247c71d817cb114382"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6bd04e06f2b1c247c71d817cb114382">kmpSearch</a> (const std::string &amp;pat, const std::string &amp;txt)</td></tr>
<tr class="separator:ab6bd04e06f2b1c247c71d817cb114382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b3bf79c6d5c2413f3bd31b909b21ba" id="r_a53b3bf79c6d5c2413f3bd31b909b21ba"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53b3bf79c6d5c2413f3bd31b909b21ba">isPalindrome</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a53b3bf79c6d5c2413f3bd31b909b21ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5a6b2a2e32759546fc105652ee34c6" id="r_aea5a6b2a2e32759546fc105652ee34c6"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:aea5a6b2a2e32759546fc105652ee34c6"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea5a6b2a2e32759546fc105652ee34c6">to_string</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:aea5a6b2a2e32759546fc105652ee34c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c60972c6e940cc87036321ae5c5136" id="r_aa6c60972c6e940cc87036321ae5c5136"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:aa6c60972c6e940cc87036321ae5c5136"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6c60972c6e940cc87036321ae5c5136">to_string</a> (std::pair&lt; T, T &gt; p)</td></tr>
<tr class="separator:aa6c60972c6e940cc87036321ae5c5136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ec3e40e27b79ffc33545635fba4503" id="r_a99ec3e40e27b79ffc33545635fba4503"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a99ec3e40e27b79ffc33545635fba4503"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99ec3e40e27b79ffc33545635fba4503">to_string</a> (const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;vec)</td></tr>
<tr class="separator:a99ec3e40e27b79ffc33545635fba4503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee4965999b2d0f38f92441754701ebd" id="r_a4ee4965999b2d0f38f92441754701ebd"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ee4965999b2d0f38f92441754701ebd">to_string</a> (const std::vector&lt; std::string &gt; &amp;vec)</td></tr>
<tr class="separator:a4ee4965999b2d0f38f92441754701ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611d2268215b58fd16cde84613d4fc6b" id="r_a611d2268215b58fd16cde84613d4fc6b"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a611d2268215b58fd16cde84613d4fc6b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a611d2268215b58fd16cde84613d4fc6b">to_string</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;vec)</td></tr>
<tr class="separator:a611d2268215b58fd16cde84613d4fc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8923ef291cc64772c5cd13426cfa2091" id="r_a8923ef291cc64772c5cd13426cfa2091"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8923ef291cc64772c5cd13426cfa2091">string_split</a> (const std::string &amp;s, char delimiter)</td></tr>
<tr class="separator:a8923ef291cc64772c5cd13426cfa2091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498a70a6f910f3190ec86a937da07225" id="r_a498a70a6f910f3190ec86a937da07225"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a498a70a6f910f3190ec86a937da07225">string_repeat</a> (const std::string &amp;s, size_t n)</td></tr>
<tr class="separator:a498a70a6f910f3190ec86a937da07225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa6180d399b5d52efaa38f0d5cbdacb" id="r_adaa6180d399b5d52efaa38f0d5cbdacb"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaa6180d399b5d52efaa38f0d5cbdacb">string_repeat</a> (char c, size_t n)</td></tr>
<tr class="separator:adaa6180d399b5d52efaa38f0d5cbdacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6691641b2d50eca1b2145da55c74f1d" id="r_ac6691641b2d50eca1b2145da55c74f1d"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:ac6691641b2d50eca1b2145da55c74f1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6691641b2d50eca1b2145da55c74f1d">lessThanAll</a> (T x, T val)</td></tr>
<tr class="separator:ac6691641b2d50eca1b2145da55c74f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c0498b1070c4404daaaf087992758b" id="r_ae5c0498b1070c4404daaaf087992758b"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:ae5c0498b1070c4404daaaf087992758b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5c0498b1070c4404daaaf087992758b">lessThanAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:ae5c0498b1070c4404daaaf087992758b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9c656f40560cd6141ff708c5937b89" id="r_a8f9c656f40560cd6141ff708c5937b89"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a8f9c656f40560cd6141ff708c5937b89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f9c656f40560cd6141ff708c5937b89">lessThanOrEqualToAll</a> (T x, T val)</td></tr>
<tr class="separator:a8f9c656f40560cd6141ff708c5937b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e874c9c2bfef67800a520d9ccf60805" id="r_a0e874c9c2bfef67800a520d9ccf60805"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:a0e874c9c2bfef67800a520d9ccf60805"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e874c9c2bfef67800a520d9ccf60805">lessThanOrEqualToAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:a0e874c9c2bfef67800a520d9ccf60805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9919b9e521c5513278a973e42a1bbf42" id="r_a9919b9e521c5513278a973e42a1bbf42"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a9919b9e521c5513278a973e42a1bbf42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9919b9e521c5513278a973e42a1bbf42">greaterThanAll</a> (T x, T val)</td></tr>
<tr class="separator:a9919b9e521c5513278a973e42a1bbf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca360e3bd41a5aa9aa1873147e5bc823" id="r_aca360e3bd41a5aa9aa1873147e5bc823"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:aca360e3bd41a5aa9aa1873147e5bc823"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca360e3bd41a5aa9aa1873147e5bc823">greaterThanAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:aca360e3bd41a5aa9aa1873147e5bc823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c76cdee93b66ddae3fa5a37b42f19d" id="r_a21c76cdee93b66ddae3fa5a37b42f19d"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a21c76cdee93b66ddae3fa5a37b42f19d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21c76cdee93b66ddae3fa5a37b42f19d">greaterThanOrEqualToAll</a> (T x, T val)</td></tr>
<tr class="separator:a21c76cdee93b66ddae3fa5a37b42f19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97854002bbec586ad6d0a52ab4315e3" id="r_ae97854002bbec586ad6d0a52ab4315e3"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:ae97854002bbec586ad6d0a52ab4315e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae97854002bbec586ad6d0a52ab4315e3">greaterThanOrEqualToAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:ae97854002bbec586ad6d0a52ab4315e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6dae9bb445381d5ec6a88094c9f315" id="r_a3e6dae9bb445381d5ec6a88094c9f315"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a3e6dae9bb445381d5ec6a88094c9f315"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e6dae9bb445381d5ec6a88094c9f315">sum</a> (T x)</td></tr>
<tr class="separator:a3e6dae9bb445381d5ec6a88094c9f315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabb6992d6adc87e88949774ea718c67" id="r_adabb6992d6adc87e88949774ea718c67"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:adabb6992d6adc87e88949774ea718c67"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adabb6992d6adc87e88949774ea718c67">sum</a> (T x, Args... args)</td></tr>
<tr class="separator:adabb6992d6adc87e88949774ea718c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a218d0181825bcf526ca9e5c24f6aab06" id="r_a218d0181825bcf526ca9e5c24f6aab06"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a> = static_cast&lt;int&gt;(1e9 + 7)</td></tr>
<tr class="separator:a218d0181825bcf526ca9e5c24f6aab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9cbfd0b02206d45ef53cae53da08bde1" name="a9cbfd0b02206d45ef53cae53da08bde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbfd0b02206d45ef53cae53da08bde1">&#9670;&#160;</a></span>MonotonicDecreasingStack</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9cbfd0b02206d45ef53cae53da08bde1">hsc_snippets::MonotonicDecreasingStack</a> = <a class="el" href="classhsc__snippets_1_1MonotonicStack.html">MonotonicStack</a>&lt;T, std::less_equal&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa38155ad9e921ee6d3cf69b328f69757" name="aa38155ad9e921ee6d3cf69b328f69757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38155ad9e921ee6d3cf69b328f69757">&#9670;&#160;</a></span>MonotonicIncreasingStack</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa38155ad9e921ee6d3cf69b328f69757">hsc_snippets::MonotonicIncreasingStack</a> = <a class="el" href="classhsc__snippets_1_1MonotonicStack.html">MonotonicStack</a>&lt;T, std::greater_equal&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a795dc74a07970f538ab222b31f874271" name="a795dc74a07970f538ab222b31f874271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795dc74a07970f538ab222b31f874271">&#9670;&#160;</a></span>additive_inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::additive_inverse </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac879e738d6cc7459cdc04fbc7e60d017" name="ac879e738d6cc7459cdc04fbc7e60d017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac879e738d6cc7459cdc04fbc7e60d017">&#9670;&#160;</a></span>binary_tree_to_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; hsc_snippets::binary_tree_to_adjacency_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a binary tree to an adjacency list representation. All node values in the binary tree must be unique. The adjacency list is bidirectional, meaning for each parent-child relation, both the parent's list contains the child and the child's list contains the parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the binary tree. If the tree is empty (nullptr), the function returns an empty adjacency list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered_map where keys are node values and values are vectors of integers representing the node values of adjacent nodes. </dd></dl>

</div>
</div>
<a id="af89532c357a8e55dfcdd9b748c39ca1c" name="af89532c357a8e55dfcdd9b748c39ca1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89532c357a8e55dfcdd9b748c39ca1c">&#9670;&#160;</a></span>binary_tree_to_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::optional&lt; int &gt; &gt; hsc_snippets::binary_tree_to_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a binary tree to a vector of optional integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the binary tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of std::optional&lt;int&gt; representing the binary tree in level-order traversal. An std::nullopt value indicates the absence of a node at that position. </dd></dl>

</div>
</div>
<a id="a3b1ec5bec1478c4c998682cc18f206ef" name="a3b1ec5bec1478c4c998682cc18f206ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1ec5bec1478c4c998682cc18f206ef">&#9670;&#160;</a></span>breadth_first_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hsc_snippets::breadth_first_search </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adjacency_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int, int)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a breadth-first search (BFS) on an undirected graph starting from a given root node. It uses a queue to explore nodes level by level, ensuring each node is visited exactly once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacency_list</td><td>The graph represented as an adjacency list, where each key-value pair corresponds to a node and its list of adjacent nodes. </td></tr>
    <tr><td class="paramname">root</td><td>The starting node for the BFS. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to be called for each visited node. It takes the distance from the root and the node itself as arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6c5d7cb8bacbba1f47c93754aa41dcf" name="ae6c5d7cb8bacbba1f47c93754aa41dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c5d7cb8bacbba1f47c93754aa41dcf">&#9670;&#160;</a></span>breadth_first_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hsc_snippets::breadth_first_search </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adjacency_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int, int)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a breadth-first search (BFS) traversal on a graph represented by an adjacency list, starting from the specified root node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacency_list</td><td>The adjacency list representation of the graph. Each element represents a node and contains the indices of its adjacent nodes. </td></tr>
    <tr><td class="paramname">root</td><td>The index of the root node from which the BFS traversal starts. </td></tr>
    <tr><td class="paramname">callback</td><td>A callback function invoked for each visited node during the BFS traversal. It takes two parameters: the distance of the current node from the root and the index of the current node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f76e1d412f83567b03ef84aa374878a" name="a2f76e1d412f83567b03ef84aa374878a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f76e1d412f83567b03ef84aa374878a">&#9670;&#160;</a></span>containsInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::containsInRange </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bf59f1c3888dcf2c9ecf14bdb9a4f80" name="a7bf59f1c3888dcf2c9ecf14bdb9a4f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf59f1c3888dcf2c9ecf14bdb9a4f80">&#9670;&#160;</a></span>count_connected_components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int hsc_snippets::count_connected_components </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the number of connected components in an undirected graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adj</td><td>The graph represented as an adjacency list, where keys are node identifiers and values are lists of adjacent nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of connected components in the graph. </dd></dl>

</div>
</div>
<a id="a19dc9e7e53c53953a643e245a3419124" name="a19dc9e7e53c53953a643e245a3419124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dc9e7e53c53953a643e245a3419124">&#9670;&#160;</a></span>create_compression_mapper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt; std::function&lt; int(int)&gt;, int &gt; hsc_snippets::create_compression_mapper </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nums</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a compression mapper function for the given vector of integers.</p>
<p>This function performs coordinate compression on the input vector <code>nums</code>, mapping each unique value to a continuous index in ascending order starting from 0. The returned tuple contains a function for efficient lookup of the compressed index corresponding to any value in the original vector and the count of unique elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nums</td><td>The input vector of integers to be compressed. The vector can contain duplicate values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing:<ul>
<li>A function that maps an integer to its compressed index. The compressed index represents the position of the integer in the sorted, unique version of <code>nums</code>.</li>
<li>An integer representing the count of unique elements in <code>nums</code>.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned function captures the compressed vector by value, ensuring the integrity and lifespan of the data required for index lookup. </dd></dl>

</div>
</div>
<a id="a02082c12d950f24bf7fce02f3b297f56" name="a02082c12d950f24bf7fce02f3b297f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02082c12d950f24bf7fce02f3b297f56">&#9670;&#160;</a></span>deferred_binary_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::integral I = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; I &gt; hsc_snippets::deferred_binary_search </td>
          <td>(</td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a binary search on a function-generated sequence of values to find a specific value. This function assumes that the values generated by <code>func</code> are in a non-decreasing order within the specified range of indices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values generated by the function and the type of <code>value</code>. </td></tr>
    <tr><td class="paramname">I</td><td>The integral type used for indexing, with a default of int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>The lowest index of the search range (inclusive). </td></tr>
    <tr><td class="paramname">high</td><td>The highest index of the search range (inclusive). </td></tr>
    <tr><td class="paramname">value</td><td>The target value to search for within the function-generated sequence. </td></tr>
    <tr><td class="paramname">func</td><td>A callable that takes an index of type I and returns a value of type T. This function must return values in a non-decreasing order over the range [low, high]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;I&gt; containing the index at which the value equals <code>func(index)</code>, or std::nullopt if no such index exists. </dd></dl>

</div>
</div>
<a id="a9020303fa26c0f607fcb4059d0e919cf" name="a9020303fa26c0f607fcb4059d0e919cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9020303fa26c0f607fcb4059d0e919cf">&#9670;&#160;</a></span>deferred_lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::integral I = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I hsc_snippets::deferred_lower_bound </td>
          <td>(</td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the first position in [low, high] where func(position) is greater than or equal to value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>The start of the search range (inclusive). </td></tr>
    <tr><td class="paramname">high</td><td>The end of the search range (inclusive). </td></tr>
    <tr><td class="paramname">value</td><td>The target value for comparison. </td></tr>
    <tr><td class="paramname">func</td><td>A callable that returns values in a non-decreasing order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first position where func(position) is not less than value. </dd></dl>

</div>
</div>
<a id="aecad31f49f44ade0971cb68062a4044d" name="aecad31f49f44ade0971cb68062a4044d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecad31f49f44ade0971cb68062a4044d">&#9670;&#160;</a></span>deferred_lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::integral I = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I hsc_snippets::deferred_lower_bound </td>
          <td>(</td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the first position in [low, high] where func(position) is greater than or equal to value, using a custom comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>The start of the search range (inclusive). </td></tr>
    <tr><td class="paramname">high</td><td>The end of the search range (inclusive). </td></tr>
    <tr><td class="paramname">value</td><td>The target value for comparison. </td></tr>
    <tr><td class="paramname">func</td><td>A callable that returns values in a non-decreasing order. </td></tr>
    <tr><td class="paramname">comp</td><td>A comparator to compare func(position) and value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first position where !comp(func(position), value). </dd></dl>

</div>
</div>
<a id="a092b51d2598ce4226eb601e044152bc8" name="a092b51d2598ce4226eb601e044152bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092b51d2598ce4226eb601e044152bc8">&#9670;&#160;</a></span>deferred_upper_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::integral I = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I hsc_snippets::deferred_upper_bound </td>
          <td>(</td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the first position in [low, high] where func(position) is strictly greater than value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>The start of the search range (inclusive). </td></tr>
    <tr><td class="paramname">high</td><td>The end of the search range (inclusive). </td></tr>
    <tr><td class="paramname">value</td><td>The target value for comparison. </td></tr>
    <tr><td class="paramname">func</td><td>A callable that returns values in a non-decreasing order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first position where func(position) is greater than value. </dd></dl>

</div>
</div>
<a id="a36174f67e1f87d9f5a216eb4d89fa48f" name="a36174f67e1f87d9f5a216eb4d89fa48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36174f67e1f87d9f5a216eb4d89fa48f">&#9670;&#160;</a></span>deferred_upper_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::integral I = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I hsc_snippets::deferred_upper_bound </td>
          <td>(</td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the first position in [low, high] where func(position) is strictly greater than value, using a custom comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>The start of the search range (inclusive). </td></tr>
    <tr><td class="paramname">high</td><td>The end of the search range (inclusive). </td></tr>
    <tr><td class="paramname">value</td><td>The target value for comparison. </td></tr>
    <tr><td class="paramname">func</td><td>A callable that returns values in a non-decreasing order. </td></tr>
    <tr><td class="paramname">comp</td><td>A comparator to compare func(position) and value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first position where comp(value, func(position)) returns true. </dd></dl>

</div>
</div>
<a id="a0e3d7e58268e86266dfc92d8c0518707" name="a0e3d7e58268e86266dfc92d8c0518707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3d7e58268e86266dfc92d8c0518707">&#9670;&#160;</a></span>delete_binary_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hsc_snippets::delete_binary_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes all nodes of a binary tree to free memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the binary tree. If the pointer is nullptr, the function does nothing, safely handling the case of an empty tree or reaching the end of a branch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d7d53ab011791a0531e5bcd779f3793" name="a8d7d53ab011791a0531e5bcd779f3793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7d53ab011791a0531e5bcd779f3793">&#9670;&#160;</a></span>depth_first_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hsc_snippets::depth_first_search </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adjacency_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int, int)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a depth-first search (DFS) traversal on a graph represented by an adjacency list, starting from the specified root node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacency_list</td><td>The adjacency list representation of the graph. Each element represents a node and contains the indices of its adjacent nodes. </td></tr>
    <tr><td class="paramname">root</td><td>The index of the root node from which the DFS traversal starts. </td></tr>
    <tr><td class="paramname">callback</td><td>A callback function invoked for each visited node during the DFS traversal. It takes two parameters: the distance of the current node from the root and the index of the current node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a000828beeb1f7645e3c72a63c7b7fa92" name="a000828beeb1f7645e3c72a63c7b7fa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000828beeb1f7645e3c72a63c7b7fa92">&#9670;&#160;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int hsc_snippets::dijkstra </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adjacency_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dijkstra's algorithm to find the shortest path from source to destination in a graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of vertices in the graph. </td></tr>
    <tr><td class="paramname">adjacency_list</td><td>Adjacency list representation of the graph where each element is a pair representing an edge (to, weight). </td></tr>
    <tr><td class="paramname">src</td><td>Source vertex. </td></tr>
    <tr><td class="paramname">dst</td><td>Destination vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shortest distance from source to destination. Returns -1 if no path exists. </dd></dl>

</div>
</div>
<a id="a158980980e40006ca0b81338ad6c0408" name="a158980980e40006ca0b81338ad6c0408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158980980e40006ca0b81338ad6c0408">&#9670;&#160;</a></span>find_connected_components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::vector&lt; int &gt; &gt; hsc_snippets::find_connected_components </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds and returns all connected components in an undirected graph. It iterates over all nodes, using a BFS starting from each unvisited node to discover all nodes in the same connected component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adj</td><td>The graph represented as an adjacency list, where keys are node identifiers and values are lists of adjacent nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors, where each inner vector represents a connected component of the graph and contains all node identifiers within that component. </dd></dl>

</div>
</div>
<a id="ac0021648770f8ed93a2d6e0fb224894e" name="ac0021648770f8ed93a2d6e0fb224894e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0021648770f8ed93a2d6e0fb224894e">&#9670;&#160;</a></span>find_euler_path_directed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; int &gt; hsc_snippets::find_euler_path_directed </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an Eulerian path or circuit in a directed graph.</p>
<p>This function assumes that the given graph has an Eulerian path or circuit, which means the graph is connected and either: </p>
<ul>
<li>All vertices have equal in-degrees and out-degrees (Eulerian circuit), or </li>
</ul>
<ul>
<li>All but two vertices have equal in-degrees and out-degrees, and one of those two vertices has out-degree = in-degree + 1 (start), and the other has in-degree = out-degree + 1 (end) (Eulerian path).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>A vector of pairs representing directed edges in the graph. Each pair (a, b) represents a directed edge from a to b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector representing the Eulerian path or circuit as a sequence of vertex indices. If a circuit exists, the path can start from any vertex in the circuit. </dd></dl>

</div>
</div>
<a id="afff61e6f2efed27bc4bbb2a2c6a44328" name="afff61e6f2efed27bc4bbb2a2c6a44328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff61e6f2efed27bc4bbb2a2c6a44328">&#9670;&#160;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::gcd </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A numeric type that should be an integral type (e.g., int, long). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number. </td></tr>
    <tr><td class="paramname">b</td><td>The second number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest common divisor of a and b. </dd></dl>

</div>
</div>
<a id="a41d508b22e8ae3deb4ae7b5f75e968f3" name="a41d508b22e8ae3deb4ae7b5f75e968f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d508b22e8ae3deb4ae7b5f75e968f3">&#9670;&#160;</a></span>get_binary_tree_depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int hsc_snippets::get_binary_tree_depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the depth of a binary tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the binary tree. If the tree is empty (nullptr), the depth is considered to be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The depth of the binary tree as an integer. An empty tree has a depth of 0. </dd></dl>

</div>
</div>
<a id="aa55a2dd20854e1a9cb1b397d7368ee1c" name="aa55a2dd20854e1a9cb1b397d7368ee1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55a2dd20854e1a9cb1b397d7368ee1c">&#9670;&#160;</a></span>get_linked_list_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int hsc_snippets::get_linked_list_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the length of a linked list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to the head of the linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes in the linked list. </dd></dl>

</div>
</div>
<a id="a99ce4368d4f4c5ca1ab4959cd68c95b6" name="a99ce4368d4f4c5ca1ab4959cd68c95b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ce4368d4f4c5ca1ab4959cd68c95b6">&#9670;&#160;</a></span>getPrefixMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; T &gt; hsc_snippets::getPrefixMax </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the prefix maximums of a given vector. </p>
<p>This function returns a vector where each element at index <code>i</code> contains the maximum value in the inclusive subarray <code>v[0]</code> to <code>v[i]</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of the elements in the input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector of integral type T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; A vector of the same size as <code>v</code>, where each element at index <code>i</code> is the maximum value of the inclusive subarray <code>v[0]</code> to <code>v[i]</code>. </dd></dl>

</div>
</div>
<a id="a96d8767443119ae94d6401e750df49d4" name="a96d8767443119ae94d6401e750df49d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d8767443119ae94d6401e750df49d4">&#9670;&#160;</a></span>getPrefixMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; T &gt; hsc_snippets::getPrefixMin </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the prefix minimums of a given vector. </p>
<p>This function returns a vector where each element at index <code>i</code> contains the minimum value in the inclusive subarray <code>v[0]</code> to <code>v[i]</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of the elements in the input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector of integral type T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; A vector of the same size as <code>v</code>, where each element at index <code>i</code> is the minimum value of the inclusive subarray <code>v[0]</code> to <code>v[i]</code>. </dd></dl>

</div>
</div>
<a id="ac3d6c4d4f4ddd13119de137ddcef7d46" name="ac3d6c4d4f4ddd13119de137ddcef7d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d6c4d4f4ddd13119de137ddcef7d46">&#9670;&#160;</a></span>getPrefixSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; T &gt; hsc_snippets::getPrefixSum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the prefix sums of a given vector. </p>
<p>This function returns a vector where each element at index <code>i</code> contains the sum of the elements in the inclusive subarray <code>v[0]</code> to <code>v[i]</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of the elements in the input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector of integral type T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; A vector of the same size as <code>v</code>, where each element at index <code>i</code> is the sum of the elements in the inclusive subarray <code>v[0]</code> to <code>v[i]</code>. </dd></dl>

</div>
</div>
<a id="a5d62a802305764f19b2a54a23404d1b6" name="a5d62a802305764f19b2a54a23404d1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d62a802305764f19b2a54a23404d1b6">&#9670;&#160;</a></span>getSuffixMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; T &gt; hsc_snippets::getSuffixMax </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the suffix maximums of a given vector. </p>
<p>This function returns a vector where each element at index <code>i</code> contains the maximum value in the inclusive subarray <code>v[i]</code> to <code>v[n-1]</code>, where <code>n</code> is the size of the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of the elements in the input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector of integral type T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; A vector of the same size as <code>v</code>, where each element at index <code>i</code> is the maximum value of the inclusive subarray <code>v[i]</code> to <code>v[n-1]</code>. </dd></dl>

</div>
</div>
<a id="a33c06b519aff691bfd054ba9bb3c1ef3" name="a33c06b519aff691bfd054ba9bb3c1ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c06b519aff691bfd054ba9bb3c1ef3">&#9670;&#160;</a></span>getSuffixMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; T &gt; hsc_snippets::getSuffixMin </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the suffix minimums of a given vector. </p>
<p>This function returns a vector where each element at index <code>i</code> contains the minimum value in the inclusive subarray <code>v[i]</code> to <code>v[n-1]</code>, where <code>n</code> is the size of the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of the elements in the input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector of integral type T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; A vector of the same size as <code>v</code>, where each element at index <code>i</code> is the minimum value of the inclusive subarray <code>v[i]</code> to <code>v[n-1]</code>. </dd></dl>

</div>
</div>
<a id="a201f499f92fb7f8d6bc0994f12787d3f" name="a201f499f92fb7f8d6bc0994f12787d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201f499f92fb7f8d6bc0994f12787d3f">&#9670;&#160;</a></span>getSuffixSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; T &gt; hsc_snippets::getSuffixSum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the suffix sums of a given vector. </p>
<p>This function returns a vector where each element at index <code>i</code> contains the sum of the elements in the inclusive subarray <code>v[i]</code> to <code>v[n-1]</code>, where <code>n</code> is the size of the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of the elements in the input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector of integral type T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; A vector of the same size as <code>v</code>, where each element at index <code>i</code> is the sum of the elements in the inclusive subarray <code>v[i]</code> to <code>v[n-1]</code>. </dd></dl>

</div>
</div>
<a id="a9919b9e521c5513278a973e42a1bbf42" name="a9919b9e521c5513278a973e42a1bbf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9919b9e521c5513278a973e42a1bbf42">&#9670;&#160;</a></span>greaterThanAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca360e3bd41a5aa9aa1873147e5bc823" name="aca360e3bd41a5aa9aa1873147e5bc823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca360e3bd41a5aa9aa1873147e5bc823">&#9670;&#160;</a></span>greaterThanAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21c76cdee93b66ddae3fa5a37b42f19d" name="a21c76cdee93b66ddae3fa5a37b42f19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c76cdee93b66ddae3fa5a37b42f19d">&#9670;&#160;</a></span>greaterThanOrEqualToAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae97854002bbec586ad6d0a52ab4315e3" name="ae97854002bbec586ad6d0a52ab4315e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97854002bbec586ad6d0a52ab4315e3">&#9670;&#160;</a></span>greaterThanOrEqualToAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb08fb820f5c795965a4f91467c91f3f" name="abb08fb820f5c795965a4f91467c91f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb08fb820f5c795965a4f91467c91f3f">&#9670;&#160;</a></span>inorder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hsc_snippets::inorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In-order traversal of a binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node of the binary tree. </td></tr>
    <tr><td class="paramname">func</td><td>Function to process each node's value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53b3bf79c6d5c2413f3bd31b909b21ba" name="a53b3bf79c6d5c2413f3bd31b909b21ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b3bf79c6d5c2413f3bd31b909b21ba">&#9670;&#160;</a></span>isPalindrome()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hsc_snippets::isPalindrome </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if a given string is a palindrome.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to check for palindromicity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 's' is a palindrome, False otherwise. </dd></dl>

</div>
</div>
<a id="a7ca516ac018a2770d79d6fe162f497d1" name="a7ca516ac018a2770d79d6fe162f497d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca516ac018a2770d79d6fe162f497d1">&#9670;&#160;</a></span>isPerfectSquare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hsc_snippets::isPerfectSquare </td>
          <td>(</td>
          <td class="paramtype">std::int32_t</td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if a given number is a perfect square using a precomputed array of squares.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The number to check if it is a perfect square. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if num is a perfect square, otherwise false. </dd></dl>

</div>
</div>
<a id="ab6bd04e06f2b1c247c71d817cb114382" name="ab6bd04e06f2b1c247c71d817cb114382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bd04e06f2b1c247c71d817cb114382">&#9670;&#160;</a></span>kmpSearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; int &gt; hsc_snippets::kmpSearch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>txt</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for all occurrences of a pattern within a text using the Knuth-Morris-Pratt (KMP) algorithm.</p>
<p>The KMP algorithm pre-processes the pattern to construct an array of longest proper prefixes which are also suffixes (LPS array). It then uses this LPS array to skip redundant comparisons when a mismatch occurs, thereby improving the search efficiency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pat</td><td>The pattern string to search for within the text. </td></tr>
    <tr><td class="paramname">txt</td><td>The text string in which to search for the pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the starting indices of all occurrences of 'pat' within 'txt'. </dd></dl>

</div>
</div>
<a id="af1c5f4718fb5c5d24e6b7ef9f1ede860" name="af1c5f4718fb5c5d24e6b7ef9f1ede860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c5f4718fb5c5d24e6b7ef9f1ede860">&#9670;&#160;</a></span>largestRectangleInHistogram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int hsc_snippets::largestRectangleInHistogram </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>heights</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LeetCode 84: Largest Rectangle in Histogram This function calculates the maximum area of a rectangle that can be formed within a given histogram. Each bar's height is given in the 'heights' vector, where each element represents the height of a bar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heights</td><td>A vector of integers where each integer represents the height of a histogram bar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum area of the rectangle that can be formed in the histogram. </dd></dl>

</div>
</div>
<a id="a9d31a87aa5ed5297257e6daea49a4c72" name="a9d31a87aa5ed5297257e6daea49a4c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d31a87aa5ed5297257e6daea49a4c72">&#9670;&#160;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::lcm </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the least common multiple (LCM) of two numbers using the formula: LCM(a, b) = (a * b) / GCD(a, b)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A numeric type that should be an integral type (e.g., int, long). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number. </td></tr>
    <tr><td class="paramname">b</td><td>The second number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The least common multiple of a and b. </dd></dl>

</div>
</div>
<a id="ac6691641b2d50eca1b2145da55c74f1d" name="ac6691641b2d50eca1b2145da55c74f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6691641b2d50eca1b2145da55c74f1d">&#9670;&#160;</a></span>lessThanAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5c0498b1070c4404daaaf087992758b" name="ae5c0498b1070c4404daaaf087992758b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c0498b1070c4404daaaf087992758b">&#9670;&#160;</a></span>lessThanAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f9c656f40560cd6141ff708c5937b89" name="a8f9c656f40560cd6141ff708c5937b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9c656f40560cd6141ff708c5937b89">&#9670;&#160;</a></span>lessThanOrEqualToAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e874c9c2bfef67800a520d9ccf60805" name="a0e874c9c2bfef67800a520d9ccf60805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e874c9c2bfef67800a520d9ccf60805">&#9670;&#160;</a></span>lessThanOrEqualToAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00a04f3114efd0152b433b11da85238e" name="a00a04f3114efd0152b433b11da85238e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a04f3114efd0152b433b11da85238e">&#9670;&#160;</a></span>linked_list_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hsc_snippets::linked_list_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes all nodes in a linked list to free memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to the head of the linked list to be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c7f423ee4b9024557d8497b2c46755d" name="a0c7f423ee4b9024557d8497b2c46755d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7f423ee4b9024557d8497b2c46755d">&#9670;&#160;</a></span>linked_list_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> * hsc_snippets::linked_list_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes nodes from a linked list in the specified range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list. </td></tr>
    <tr><td class="paramname">begin</td><td>The starting index of the range to remove nodes (inclusive). </td></tr>
    <tr><td class="paramname">end</td><td>The ending index of the range to remove nodes (exclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the head of the modified linked list. </dd></dl>

</div>
</div>
<a id="afad15a7a05a44dbdde22dd2a4bb4327f" name="afad15a7a05a44dbdde22dd2a4bb4327f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad15a7a05a44dbdde22dd2a4bb4327f">&#9670;&#160;</a></span>linked_list_to_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; int &gt; hsc_snippets::linked_list_to_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a linked list to a vector of integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to the head of the linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of integers containing the values of the linked list nodes. </dd></dl>

</div>
</div>
<a id="a5b6a5ac55d0bc6bbef668820bd517111" name="a5b6a5ac55d0bc6bbef668820bd517111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6a5ac55d0bc6bbef668820bd517111">&#9670;&#160;</a></span>make_linked_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structhsc__snippets_1_1ListNode.html">ListNode</a> * hsc_snippets::make_linked_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a linked list from a vector of integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A reference to a vector of integers from which to create the linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the head of the newly created linked list. </dd></dl>

</div>
</div>
<a id="a3384a2049e5e30e2b4aa10550175daa6" name="a3384a2049e5e30e2b4aa10550175daa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3384a2049e5e30e2b4aa10550175daa6">&#9670;&#160;</a></span>make_unweighted_directed_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::vector&lt; int &gt; &gt; hsc_snippets::make_unweighted_directed_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an unweighted, directed adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains two integers: [from, to], denoting a directed edge from node 'from' to node 'to'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors representing the adjacency list of the graph. Each inner vector corresponds to a node, containing the indices of connected nodes (edges are unweighted in this representation). </dd></dl>

</div>
</div>
<a id="af6c27454d2b8c5a9c354da37c60ada0f" name="af6c27454d2b8c5a9c354da37c60ada0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c27454d2b8c5a9c354da37c60ada0f">&#9670;&#160;</a></span>make_unweighted_undirected_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::vector&lt; int &gt; &gt; hsc_snippets::make_unweighted_undirected_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an unweighted, undirected adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains two integers: [from, to], denoting an edge from node 'from' to node 'to'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors representing the adjacency list of the graph. Each inner vector corresponds to a node, containing the indices of connected nodes (edges are unweighted in this representation). </dd></dl>

</div>
</div>
<a id="a58ea5ef53cab9fb29f63a5951becb70e" name="a58ea5ef53cab9fb29f63a5951becb70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ea5ef53cab9fb29f63a5951becb70e">&#9670;&#160;</a></span>make_weighted_directed_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt; hsc_snippets::make_weighted_directed_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a weighted, directed adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains three integers: [from, to, weight], denoting a weighted edge from node 'from' to node 'to' with the given weight. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors of pairs representing the adjacency list of the graph. Each inner vector corresponds to a node, containing pairs of connected nodes and their respective edge weights. </dd></dl>

</div>
</div>
<a id="a6ec6e85a62b0f66d37d62604c0088c37" name="a6ec6e85a62b0f66d37d62604c0088c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec6e85a62b0f66d37d62604c0088c37">&#9670;&#160;</a></span>make_weighted_undirected_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt; hsc_snippets::make_weighted_undirected_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a weighted, undirected adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains three integers: [from, to, weight], denoting a weighted edge between node 'from' and node 'to' with the given weight. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors of pairs representing the adjacency list of the graph. Each inner vector corresponds to a node, containing pairs of connected nodes and their respective edge weights. </dd></dl>

</div>
</div>
<a id="a7c058184d3bf4b4028ac27888f891666" name="a7c058184d3bf4b4028ac27888f891666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c058184d3bf4b4028ac27888f891666">&#9670;&#160;</a></span>modular_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_add </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a69f0c52364cd0e82d19151f1d05aee8c" name="a69f0c52364cd0e82d19151f1d05aee8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f0c52364cd0e82d19151f1d05aee8c">&#9670;&#160;</a></span>modular_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_cube </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36dc1f9c8622b338e040c3d0746ffa45" name="a36dc1f9c8622b338e040c3d0746ffa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36dc1f9c8622b338e040c3d0746ffa45">&#9670;&#160;</a></span>modular_multiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_multiply </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8614f9b32030042e88023008f23a68e1" name="a8614f9b32030042e88023008f23a68e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8614f9b32030042e88023008f23a68e1">&#9670;&#160;</a></span>modular_pow2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int hsc_snippets::modular_pow2 </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab24c9c4d4245ec401fd40ecb1a12c1b6" name="ab24c9c4d4245ec401fd40ecb1a12c1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24c9c4d4245ec401fd40ecb1a12c1b6">&#9670;&#160;</a></span>modular_square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_square </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07b713f9ee2ad0ce059e4f017d5e3e87" name="a07b713f9ee2ad0ce059e4f017d5e3e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b713f9ee2ad0ce059e4f017d5e3e87">&#9670;&#160;</a></span>modular_subtract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_subtract </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a136d6a09342381325d92a6c9d17a3fac" name="a136d6a09342381325d92a6c9d17a3fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136d6a09342381325d92a6c9d17a3fac">&#9670;&#160;</a></span>new_binary_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> * hsc_snippets::new_binary_tree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::optional&lt; int &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a binary tree from a vector of optional integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A vector of std::optional&lt;int&gt;, where each element represents a potential node in the binary tree. An std::nullopt value indicates the absence of a node at that position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the root node of the newly constructed binary tree. Returns nullptr if the input vector is empty. </dd></dl>

</div>
</div>
<a id="a58ccbeb569860677c784f504351db1d8" name="a58ccbeb569860677c784f504351db1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ccbeb569860677c784f504351db1d8">&#9670;&#160;</a></span>nextGreaterElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; hsc_snippets::nextGreaterElement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nums</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; T()&gt;</td>          <td class="paramname"><span class="paramname"><em>no_greater</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the next greater element for each element in a sequence. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements in the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nums</td><td>The sequence of elements. </td></tr>
    <tr><td class="paramname">no_greater</td><td>Function to call when no greater element is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the next greater element for each element in <code>nums</code>. </dd></dl>

</div>
</div>
<a id="a9dc8f948cda1de6cbdb67bf6680d87f9" name="a9dc8f948cda1de6cbdb67bf6680d87f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc8f948cda1de6cbdb67bf6680d87f9">&#9670;&#160;</a></span>numBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::numBits </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of bits required to represent an integer in binary. For negative numbers, it returns the number of bits in the type (e.g., 32 for int), assuming two's complement representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the input number, constrained to integral types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The input number whose binary bit count is to be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bits required to represent num in binary, or the bit size of T for negative numbers. </dd></dl>

</div>
</div>
<a id="a21faa054d1afffbd2d869a99a54209de" name="a21faa054d1afffbd2d869a99a54209de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21faa054d1afffbd2d869a99a54209de">&#9670;&#160;</a></span>numDigits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::numDigits </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of digits in the decimal representation of an integer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the input number, constrained to integral types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The input number whose number of decimal digits is to be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of digits in the decimal representation of num. </dd></dl>

</div>
</div>
<a id="a770cc063eb04b7231b755c72383511d3" name="a770cc063eb04b7231b755c72383511d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770cc063eb04b7231b755c72383511d3">&#9670;&#160;</a></span>numOfGreaterElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::totally_ordered T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::numOfGreaterElements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a434872c7db853da32dcaf6254abf53bd" name="a434872c7db853da32dcaf6254abf53bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434872c7db853da32dcaf6254abf53bd">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hsc_snippets::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>interval</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad46c82943972e1cda8e400b287ca10e4" name="ad46c82943972e1cda8e400b287ca10e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46c82943972e1cda8e400b287ca10e4">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hsc_snippets::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>interval1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>interval2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4893ca5a1d94f3b1c7ed3768bb4c3a3a" name="a4893ca5a1d94f3b1c7ed3768bb4c3a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4893ca5a1d94f3b1c7ed3768bb4c3a3a">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hsc_snippets::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1Interval.html">Interval</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>interval</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a1a49963ffe7f4d3761fb9b13145092" name="a7a1a49963ffe7f4d3761fb9b13145092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1a49963ffe7f4d3761fb9b13145092">&#9670;&#160;</a></span>postorder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hsc_snippets::postorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Post-order traversal of a binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node of the binary tree. </td></tr>
    <tr><td class="paramname">func</td><td>Function to process each node's value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a634fab7f601ccfc94bf4a3c1d60332fe" name="a634fab7f601ccfc94bf4a3c1d60332fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634fab7f601ccfc94bf4a3c1d60332fe">&#9670;&#160;</a></span>preorder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hsc_snippets::preorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1TreeNode.html">TreeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pre-order traversal of a binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node of the binary tree. </td></tr>
    <tr><td class="paramname">func</td><td>Function to process each node's value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63947c3cdde506a8b9d7c658b77c9ce3" name="a63947c3cdde506a8b9d7c658b77c9ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63947c3cdde506a8b9d7c658b77c9ce3">&#9670;&#160;</a></span>SieveOfEratosthenes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; int &gt; hsc_snippets::SieveOfEratosthenes </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the Sieve of Eratosthenes algorithm to find all prime numbers up to a given limit n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The upper limit (inclusive) up to which prime numbers are to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;int&gt; containing all the prime numbers less than or equal to n. </dd></dl>

</div>
</div>
<a id="adbdb05e51cc5a1ab1a9b3aea8075b2ef" name="adbdb05e51cc5a1ab1a9b3aea8075b2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdb05e51cc5a1ab1a9b3aea8075b2ef">&#9670;&#160;</a></span>sortThree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::sortThree </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts three elements in non-decreasing order using a simple comparison and swap algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements to be sorted. Must be an integral type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Reference to the first element, will be the smallest after sorting. </td></tr>
    <tr><td class="paramname">b</td><td>Reference to the second element, will be the middle element after sorting. </td></tr>
    <tr><td class="paramname">c</td><td>Reference to the third element, will be the largest after sorting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaa6180d399b5d52efaa38f0d5cbdacb" name="adaa6180d399b5d52efaa38f0d5cbdacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa6180d399b5d52efaa38f0d5cbdacb">&#9670;&#160;</a></span>string_repeat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string hsc_snippets::string_repeat </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Repeats a given character <code>c</code> for <code>n</code> times, producing a new string.</p>
<p>This function creates a string consisting of the character <code>c</code> repeated <code>n</code> times. It efficiently initializes the string with the required size and fills it with the character <code>c</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to be repeated. </td></tr>
    <tr><td class="paramname">n</td><td>The number of times to repeat the character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string consisting of the character <code>c</code> repeated <code>n</code> times. If <code>n</code> is 0, returns an empty string. </dd></dl>

</div>
</div>
<a id="a498a70a6f910f3190ec86a937da07225" name="a498a70a6f910f3190ec86a937da07225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498a70a6f910f3190ec86a937da07225">&#9670;&#160;</a></span>string_repeat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string hsc_snippets::string_repeat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Repeats a given string <code>s</code> for <code>n</code> times efficiently.</p>
<p>This function creates a new string by repeating the input string <code>s</code> for <code>n</code> times. It pre-allocates the required memory and employs a doubling strategy to minimize the number of concatenations, which enhances performance, especially for large <code>n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to be repeated. </td></tr>
    <tr><td class="paramname">n</td><td>The number of times to repeat the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new string consisting of <code>s</code> repeated <code>n</code> times. </dd></dl>

</div>
</div>
<a id="a8923ef291cc64772c5cd13426cfa2091" name="a8923ef291cc64772c5cd13426cfa2091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8923ef291cc64772c5cd13426cfa2091">&#9670;&#160;</a></span>string_split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::string &gt; hsc_snippets::string_split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Splits a given string into a vector of substrings based on a specified delimiter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The input string to be split. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character used as the delimiter to split the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of substrings obtained by splitting the input string by the delimiter. </dd></dl>

</div>
</div>
<a id="afab5e0be351fbd951110f389d9bc1914" name="afab5e0be351fbd951110f389d9bc1914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab5e0be351fbd951110f389d9bc1914">&#9670;&#160;</a></span>subarraysWithAtMostKDistinct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int hsc_snippets::subarraysWithAtMostKDistinct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nums</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts subarrays with at most <code>k</code> distinct integers using a sliding window approach.</p>
<p>Related LeetCode Problem: <a href="https://leetcode.com/problems/subarrays-with-k-different-integers/description/">https://leetcode.com/problems/subarrays-with-k-different-integers/description/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nums</td><td>A vector of integers. </td></tr>
    <tr><td class="paramname">k</td><td>The maximum number of distinct integers allowed in a subarray. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total count of such subarrays. </dd></dl>

</div>
</div>
<a id="a3e6dae9bb445381d5ec6a88094c9f315" name="a3e6dae9bb445381d5ec6a88094c9f315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6dae9bb445381d5ec6a88094c9f315">&#9670;&#160;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::sum </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adabb6992d6adc87e88949774ea718c67" name="adabb6992d6adc87e88949774ea718c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabb6992d6adc87e88949774ea718c67">&#9670;&#160;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::sum </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99ec3e40e27b79ffc33545635fba4503" name="a99ec3e40e27b79ffc33545635fba4503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ec3e40e27b79ffc33545635fba4503">&#9670;&#160;</a></span>to_string() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; T, T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a vector of pairs of integral type T to its string representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of the elements in the pairs within the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of pairs to convert to a string representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the vector of pairs, formatted as "[{first1, second1}, {first2, second2}, ...]". </dd></dl>

</div>
</div>
<a id="a4ee4965999b2d0f38f92441754701ebd" name="a4ee4965999b2d0f38f92441754701ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee4965999b2d0f38f92441754701ebd">&#9670;&#160;</a></span>to_string() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a vector of strings to its string representation, with elements separated by commas. The resulting string is enclosed in square brackets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of strings to convert. Each element in the vector is expected to be a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the vector's contents, formatted as "[element1, element2, ...]". If the vector is empty, the returned string will be "[]". </dd></dl>

</div>
</div>
<a id="a611d2268215b58fd16cde84613d4fc6b" name="a611d2268215b58fd16cde84613d4fc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611d2268215b58fd16cde84613d4fc6b">&#9670;&#160;</a></span>to_string() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a vector of vectors of integral type T to its string representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of elements in the vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of vectors to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the vector of vectors. </dd></dl>

</div>
</div>
<a id="aea5a6b2a2e32759546fc105652ee34c6" name="aea5a6b2a2e32759546fc105652ee34c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5a6b2a2e32759546fc105652ee34c6">&#9670;&#160;</a></span>to_string() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a vector of integral type T to its string representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of elements in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the vector. </dd></dl>

</div>
</div>
<a id="aa6c60972c6e940cc87036321ae5c5136" name="aa6c60972c6e940cc87036321ae5c5136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c60972c6e940cc87036321ae5c5136">&#9670;&#160;</a></span>to_string() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; T, T &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a pair of integral type T to its string representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of the pair elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pair to convert to a string representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the pair, formatted as "{first, second}". </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a218d0181825bcf526ca9e5c24f6aab06" name="a218d0181825bcf526ca9e5c24f6aab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218d0181825bcf526ca9e5c24f6aab06">&#9670;&#160;</a></span>MODULO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::MODULO = static_cast&lt;int&gt;(1e9 + 7)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
