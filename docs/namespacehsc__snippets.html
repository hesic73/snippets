<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>snippets: hsc_snippets Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">snippets
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hsc_snippets Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1_dominant_tracker.html">DominantTracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1___interval.html">_Interval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1_override.html">Override</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhsc__snippets_1_1_maximum.html">Maximum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1_interval_map.html">IntervalMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1_monotonic_stack.html">MonotonicStack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1_segment_tree.html">SegmentTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1_sliding_window_max.html">SlidingWindowMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhsc__snippets_1_1_union_find.html">UnionFind</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8814dd019634154084f05d2a91266622"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8814dd019634154084f05d2a91266622"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a8814dd019634154084f05d2a91266622">MonotonicDecreasingStack</a> = <a class="el" href="classhsc__snippets_1_1_monotonic_stack.html">MonotonicStack</a>&lt; T, std::less_equal&lt; T &gt; &gt;</td></tr>
<tr class="separator:a8814dd019634154084f05d2a91266622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad4ce1eaacbe2b20277adf8a96af4a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ad4ce1eaacbe2b20277adf8a96af4a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a9ad4ce1eaacbe2b20277adf8a96af4a5">MonotonicIncreasingStack</a> = <a class="el" href="classhsc__snippets_1_1_monotonic_stack.html">MonotonicStack</a>&lt; T, std::greater_equal&lt; T &gt; &gt;</td></tr>
<tr class="separator:a9ad4ce1eaacbe2b20277adf8a96af4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a812f513d66e4108139de15d335e9cbf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a812f513d66e4108139de15d335e9cbf3">new_binary_tree</a> (const std::vector&lt; std::optional&lt; int &gt;&gt; v)</td></tr>
<tr class="separator:a812f513d66e4108139de15d335e9cbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429782e4ffeba328dbfc0339166d667c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a429782e4ffeba328dbfc0339166d667c">delete_binary_tree</a> (<a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *root)</td></tr>
<tr class="separator:a429782e4ffeba328dbfc0339166d667c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cce75b709a679ebc99a4abcdbbd7bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a26cce75b709a679ebc99a4abcdbbd7bd">get_binary_tree_depth</a> (<a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *root)</td></tr>
<tr class="separator:a26cce75b709a679ebc99a4abcdbbd7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c82b125272d02d5cdaa2169f225f85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#ac6c82b125272d02d5cdaa2169f225f85">inorder</a> (<a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *root, std::function&lt; void(int)&gt; func)</td></tr>
<tr class="separator:ac6c82b125272d02d5cdaa2169f225f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32df3d871f5bcd99ec98038fe7d7ae02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a32df3d871f5bcd99ec98038fe7d7ae02">preorder</a> (<a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *root, std::function&lt; void(int)&gt; func)</td></tr>
<tr class="separator:a32df3d871f5bcd99ec98038fe7d7ae02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8f2987db631e9af726376704c355b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a6f8f2987db631e9af726376704c355b8">postorder</a> (<a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *root, std::function&lt; void(int)&gt; func)</td></tr>
<tr class="separator:a6f8f2987db631e9af726376704c355b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4682953080265083bdf5c32d94d64bbd"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; int, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a4682953080265083bdf5c32d94d64bbd">binary_tree_to_adjacency_list</a> (<a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *root)</td></tr>
<tr class="separator:a4682953080265083bdf5c32d94d64bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9476d9c908743ec404014de4cd50b6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a1c9476d9c908743ec404014de4cd50b6">make_weighted_directed_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:a1c9476d9c908743ec404014de4cd50b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450c22d450def48b041a4dd2a3c6c333"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a450c22d450def48b041a4dd2a3c6c333">make_unweighted_undirected_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:a450c22d450def48b041a4dd2a3c6c333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9fdcf9f5e89a3867abed30f840c883"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a4f9fdcf9f5e89a3867abed30f840c883">make_weighted_undirected_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:a4f9fdcf9f5e89a3867abed30f840c883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8903642c515fa5c02500dce7f9bc9ef"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#ad8903642c515fa5c02500dce7f9bc9ef">make_unweighted_directed_adjacency_list</a> (int n, const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:ad8903642c515fa5c02500dce7f9bc9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0a80e48e879d3c68dda0b5a8055afa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a7a0a80e48e879d3c68dda0b5a8055afa">breadth_first_search</a> (std::vector&lt; std::vector&lt; int &gt;&gt; &amp;adjacency_list, int root, std::function&lt; void(int, int)&gt; callback)</td></tr>
<tr class="separator:a7a0a80e48e879d3c68dda0b5a8055afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e92cf1e38f63173173f47971670eec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a81e92cf1e38f63173173f47971670eec">breadth_first_search</a> (std::unordered_map&lt; int, std::vector&lt; int &gt;&gt; &amp;adjacency_list, int root, std::function&lt; void(int, int)&gt; callback)</td></tr>
<tr class="separator:a81e92cf1e38f63173173f47971670eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fabbb1930246a813ae92741a8d16b93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a6fabbb1930246a813ae92741a8d16b93">depth_first_search</a> (std::vector&lt; std::vector&lt; int &gt;&gt; &amp;adjacency_list, int root, std::function&lt; void(int, int)&gt; callback)</td></tr>
<tr class="separator:a6fabbb1930246a813ae92741a8d16b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bebf773bd423b05199ae6cadd87702e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a8bebf773bd423b05199ae6cadd87702e">dijkstra</a> (int n, const std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt;&gt;&gt; &amp;adjacency_list, int src, int dst)</td></tr>
<tr class="separator:a8bebf773bd423b05199ae6cadd87702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5045aafbb3add6fd38bd87a578795bee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a5045aafbb3add6fd38bd87a578795bee">find_euler_path_directed</a> (const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:a5045aafbb3add6fd38bd87a578795bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa308cca2fd4701c87f2800f67989f733"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#aa308cca2fd4701c87f2800f67989f733">findConnectedComponents</a> (std::unordered_map&lt; int, std::vector&lt; int &gt;&gt; &amp;adj)</td></tr>
<tr class="separator:aa308cca2fd4701c87f2800f67989f733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6351fc70292dcaf68d2e1a706db301"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:ade6351fc70292dcaf68d2e1a706db301"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#ade6351fc70292dcaf68d2e1a706db301">operator&lt;</a> (const <a class="el" href="structhsc__snippets_1_1___interval.html">_Interval</a>&lt; T &gt; &amp;interval, T x)</td></tr>
<tr class="separator:ade6351fc70292dcaf68d2e1a706db301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d77ba741533e46a1e0326a2e7b8442c"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a9d77ba741533e46a1e0326a2e7b8442c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a9d77ba741533e46a1e0326a2e7b8442c">operator&lt;</a> (T x, const <a class="el" href="structhsc__snippets_1_1___interval.html">_Interval</a>&lt; T &gt; &amp;interval)</td></tr>
<tr class="separator:a9d77ba741533e46a1e0326a2e7b8442c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c7b37bbc72584a6f44b005fce7e90a"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a40c7b37bbc72584a6f44b005fce7e90a"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a40c7b37bbc72584a6f44b005fce7e90a">operator&lt;</a> (const <a class="el" href="structhsc__snippets_1_1___interval.html">_Interval</a>&lt; T &gt; &amp;interval1, const <a class="el" href="structhsc__snippets_1_1___interval.html">_Interval</a>&lt; T &gt; &amp;interval2)</td></tr>
<tr class="separator:a40c7b37bbc72584a6f44b005fce7e90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c058184d3bf4b4028ac27888f891666"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a7c058184d3bf4b4028ac27888f891666">modular_add</a> (int x, int y)</td></tr>
<tr class="separator:a7c058184d3bf4b4028ac27888f891666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795dc74a07970f538ab222b31f874271"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a795dc74a07970f538ab222b31f874271">additive_inverse</a> (int x)</td></tr>
<tr class="separator:a795dc74a07970f538ab222b31f874271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b88bd1961aeceb11486a737609e862"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#af5b88bd1961aeceb11486a737609e862">modular_substract</a> (int x, int y)</td></tr>
<tr class="separator:af5b88bd1961aeceb11486a737609e862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dc1f9c8622b338e040c3d0746ffa45"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a36dc1f9c8622b338e040c3d0746ffa45">modular_multiply</a> (int x, int y)</td></tr>
<tr class="separator:a36dc1f9c8622b338e040c3d0746ffa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24c9c4d4245ec401fd40ecb1a12c1b6"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#ab24c9c4d4245ec401fd40ecb1a12c1b6">modular_square</a> (int x)</td></tr>
<tr class="separator:ab24c9c4d4245ec401fd40ecb1a12c1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f0c52364cd0e82d19151f1d05aee8c"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a69f0c52364cd0e82d19151f1d05aee8c">modular_cube</a> (int x)</td></tr>
<tr class="separator:a69f0c52364cd0e82d19151f1d05aee8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72561173b55e31dc534d5f5612a52246"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a72561173b55e31dc534d5f5612a52246">modular_pow2</a> (size_t exponent)</td></tr>
<tr class="separator:a72561173b55e31dc534d5f5612a52246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4827ed3c09b534429c5feffed16809c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4827ed3c09b534429c5feffed16809c6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a4827ed3c09b534429c5feffed16809c6">nextGreaterElement</a> (const std::vector&lt; T &gt; &amp;nums, std::function&lt; T()&gt; no_greater)</td></tr>
<tr class="separator:a4827ed3c09b534429c5feffed16809c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21faa054d1afffbd2d869a99a54209de"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a21faa054d1afffbd2d869a99a54209de"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a21faa054d1afffbd2d869a99a54209de">numDigits</a> (T num)</td></tr>
<tr class="separator:a21faa054d1afffbd2d869a99a54209de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc8f948cda1de6cbdb67bf6680d87f9"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a9dc8f948cda1de6cbdb67bf6680d87f9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a9dc8f948cda1de6cbdb67bf6680d87f9">numBits</a> (T num)</td></tr>
<tr class="separator:a9dc8f948cda1de6cbdb67bf6680d87f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff61e6f2efed27bc4bbb2a2c6a44328"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:afff61e6f2efed27bc4bbb2a2c6a44328"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#afff61e6f2efed27bc4bbb2a2c6a44328">gcd</a> (T a, T b)</td></tr>
<tr class="separator:afff61e6f2efed27bc4bbb2a2c6a44328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d31a87aa5ed5297257e6daea49a4c72"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a9d31a87aa5ed5297257e6daea49a4c72"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a9d31a87aa5ed5297257e6daea49a4c72">lcm</a> (T a, T b)</td></tr>
<tr class="separator:a9d31a87aa5ed5297257e6daea49a4c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e8a5e4bd9f4c58c06e7f66240b167c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a98e8a5e4bd9f4c58c06e7f66240b167c">SieveOfEratosthenes</a> (int n)</td></tr>
<tr class="separator:a98e8a5e4bd9f4c58c06e7f66240b167c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770cc063eb04b7231b755c72383511d3"><td class="memTemplParams" colspan="2">template&lt;std::totally_ordered T&gt; </td></tr>
<tr class="memitem:a770cc063eb04b7231b755c72383511d3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a770cc063eb04b7231b755c72383511d3">numOfGreaterElements</a> (const std::vector&lt; T &gt; &amp;v, T value)</td></tr>
<tr class="separator:a770cc063eb04b7231b755c72383511d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f76e1d412f83567b03ef84aa374878a"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a2f76e1d412f83567b03ef84aa374878a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a2f76e1d412f83567b03ef84aa374878a">containsInRange</a> (const std::vector&lt; T &gt; &amp;vec, T start, T end)</td></tr>
<tr class="separator:a2f76e1d412f83567b03ef84aa374878a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeee688cdc461cdd510e9c0e48f8c08"><td class="memTemplParams" colspan="2">template&lt;typename T , std::integral I = int&gt; </td></tr>
<tr class="memitem:aadeee688cdc461cdd510e9c0e48f8c08"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#aadeee688cdc461cdd510e9c0e48f8c08">binary_search</a> (I low, I high, const T &amp;value, auto &amp;&amp;func)</td></tr>
<tr class="separator:aadeee688cdc461cdd510e9c0e48f8c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f93655a4a72d10c318c290783a2bdc"><td class="memTemplParams" colspan="2">template&lt;typename T , std::integral I = int&gt; </td></tr>
<tr class="memitem:ac7f93655a4a72d10c318c290783a2bdc"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#ac7f93655a4a72d10c318c290783a2bdc">greatest_index</a> (I low, I high, const T &amp;value, auto &amp;&amp;func)</td></tr>
<tr class="separator:ac7f93655a4a72d10c318c290783a2bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3d0574aec6857720f3494a33cc7a85"><td class="memTemplParams" colspan="2">template&lt;typename T , std::integral I = int&gt; </td></tr>
<tr class="memitem:a8b3d0574aec6857720f3494a33cc7a85"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a8b3d0574aec6857720f3494a33cc7a85">smallest_index</a> (I low, I high, const T &amp;value, auto &amp;&amp;func)</td></tr>
<tr class="separator:a8b3d0574aec6857720f3494a33cc7a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdb05e51cc5a1ab1a9b3aea8075b2ef"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:adbdb05e51cc5a1ab1a9b3aea8075b2ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#adbdb05e51cc5a1ab1a9b3aea8075b2ef">sortThree</a> (T &amp;a, T &amp;b, T &amp;c)</td></tr>
<tr class="separator:adbdb05e51cc5a1ab1a9b3aea8075b2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8b2ad5272145a4908355c6e64d194f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#ada8b2ad5272145a4908355c6e64d194f">kmpSearch</a> (const std::string &amp;pat, const std::string &amp;txt)</td></tr>
<tr class="separator:ada8b2ad5272145a4908355c6e64d194f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1228660ec00e385121ef6171dc80d2be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a1228660ec00e385121ef6171dc80d2be">isPalindrome</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a1228660ec00e385121ef6171dc80d2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5a6b2a2e32759546fc105652ee34c6"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:aea5a6b2a2e32759546fc105652ee34c6"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#aea5a6b2a2e32759546fc105652ee34c6">to_string</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:aea5a6b2a2e32759546fc105652ee34c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64970a5102d416fdd499f71c3cd1000f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a64970a5102d416fdd499f71c3cd1000f">to_string</a> (const std::vector&lt; std::string &gt; &amp;vec)</td></tr>
<tr class="separator:a64970a5102d416fdd499f71c3cd1000f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e59e0f34998f66297969f24854dbadb"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a4e59e0f34998f66297969f24854dbadb"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a4e59e0f34998f66297969f24854dbadb">to_string</a> (const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;vec)</td></tr>
<tr class="separator:a4e59e0f34998f66297969f24854dbadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6691641b2d50eca1b2145da55c74f1d"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:ac6691641b2d50eca1b2145da55c74f1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#ac6691641b2d50eca1b2145da55c74f1d">lessThanAll</a> (T x, T val)</td></tr>
<tr class="separator:ac6691641b2d50eca1b2145da55c74f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c0498b1070c4404daaaf087992758b"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:ae5c0498b1070c4404daaaf087992758b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#ae5c0498b1070c4404daaaf087992758b">lessThanAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:ae5c0498b1070c4404daaaf087992758b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9c656f40560cd6141ff708c5937b89"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a8f9c656f40560cd6141ff708c5937b89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a8f9c656f40560cd6141ff708c5937b89">lessThanOrEqualToAll</a> (T x, T val)</td></tr>
<tr class="separator:a8f9c656f40560cd6141ff708c5937b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e874c9c2bfef67800a520d9ccf60805"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:a0e874c9c2bfef67800a520d9ccf60805"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a0e874c9c2bfef67800a520d9ccf60805">lessThanOrEqualToAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:a0e874c9c2bfef67800a520d9ccf60805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9919b9e521c5513278a973e42a1bbf42"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a9919b9e521c5513278a973e42a1bbf42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a9919b9e521c5513278a973e42a1bbf42">greaterThanAll</a> (T x, T val)</td></tr>
<tr class="separator:a9919b9e521c5513278a973e42a1bbf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca360e3bd41a5aa9aa1873147e5bc823"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:aca360e3bd41a5aa9aa1873147e5bc823"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#aca360e3bd41a5aa9aa1873147e5bc823">greaterThanAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:aca360e3bd41a5aa9aa1873147e5bc823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c76cdee93b66ddae3fa5a37b42f19d"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a21c76cdee93b66ddae3fa5a37b42f19d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a21c76cdee93b66ddae3fa5a37b42f19d">greaterThanOrEqualToAll</a> (T x, T val)</td></tr>
<tr class="separator:a21c76cdee93b66ddae3fa5a37b42f19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97854002bbec586ad6d0a52ab4315e3"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:ae97854002bbec586ad6d0a52ab4315e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#ae97854002bbec586ad6d0a52ab4315e3">greaterThanOrEqualToAll</a> (T x, T val, Args... args)</td></tr>
<tr class="separator:ae97854002bbec586ad6d0a52ab4315e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6dae9bb445381d5ec6a88094c9f315"><td class="memTemplParams" colspan="2">template&lt;numeric T&gt; </td></tr>
<tr class="memitem:a3e6dae9bb445381d5ec6a88094c9f315"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a3e6dae9bb445381d5ec6a88094c9f315">sum</a> (T x)</td></tr>
<tr class="separator:a3e6dae9bb445381d5ec6a88094c9f315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabb6992d6adc87e88949774ea718c67"><td class="memTemplParams" colspan="2">template&lt;numeric T, numeric... Args&gt; </td></tr>
<tr class="memitem:adabb6992d6adc87e88949774ea718c67"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#adabb6992d6adc87e88949774ea718c67">sum</a> (T x, Args... args)</td></tr>
<tr class="separator:adabb6992d6adc87e88949774ea718c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a218d0181825bcf526ca9e5c24f6aab06"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a> = static_cast&lt;int&gt;(1e9 + 7)</td></tr>
<tr class="separator:a218d0181825bcf526ca9e5c24f6aab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587d75f6d3f1594e5893f3fec11925c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a587d75f6d3f1594e5893f3fec11925c2"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehsc__snippets.html#a587d75f6d3f1594e5893f3fec11925c2">numeric</a> = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;</td></tr>
<tr class="separator:a587d75f6d3f1594e5893f3fec11925c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8814dd019634154084f05d2a91266622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8814dd019634154084f05d2a91266622">&#9670;&nbsp;</a></span>MonotonicDecreasingStack</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehsc__snippets.html#a8814dd019634154084f05d2a91266622">hsc_snippets::MonotonicDecreasingStack</a> = typedef <a class="el" href="classhsc__snippets_1_1_monotonic_stack.html">MonotonicStack</a>&lt;T, std::less_equal&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="monotonic__stack_8hpp_source.html#l00066">66</a> of file <a class="el" href="monotonic__stack_8hpp_source.html">monotonic_stack.hpp</a>.</p>

</div>
</div>
<a id="a9ad4ce1eaacbe2b20277adf8a96af4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad4ce1eaacbe2b20277adf8a96af4a5">&#9670;&nbsp;</a></span>MonotonicIncreasingStack</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehsc__snippets.html#a9ad4ce1eaacbe2b20277adf8a96af4a5">hsc_snippets::MonotonicIncreasingStack</a> = typedef <a class="el" href="classhsc__snippets_1_1_monotonic_stack.html">MonotonicStack</a>&lt;T, std::greater_equal&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="monotonic__stack_8hpp_source.html#l00068">68</a> of file <a class="el" href="monotonic__stack_8hpp_source.html">monotonic_stack.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a795dc74a07970f538ab222b31f874271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795dc74a07970f538ab222b31f874271">&#9670;&nbsp;</a></span>additive_inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int hsc_snippets::additive_inverse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="modular__arithmetic_8hpp_source.html#l00020">20</a> of file <a class="el" href="modular__arithmetic_8hpp_source.html">modular_arithmetic.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    {</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        x = x % <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>; <span class="comment">// x might be negative</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        x = (x + <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>) % <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a> - x;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_a218d0181825bcf526ca9e5c24f6aab06"><div class="ttname"><a href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">hsc_snippets::MODULO</a></div><div class="ttdeci">static constexpr int MODULO</div><div class="ttdef"><b>Definition:</b> <a href="modular__arithmetic_8hpp_source.html#l00010">modular_arithmetic.hpp:10</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="modular__arithmetic_8hpp_source.html#l00010">MODULO</a>.</p>

</div>
</div>
<a id="aadeee688cdc461cdd510e9c0e48f8c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadeee688cdc461cdd510e9c0e48f8c08">&#9670;&nbsp;</a></span>binary_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::integral I = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;I&gt; hsc_snippets::binary_search </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sorted__utils_8hpp_source.html#l00045">45</a> of file <a class="el" href="sorted__utils_8hpp_source.html">sorted_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160; </div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="keywordflow">while</span> (low &lt;= high)</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;            I mid = low + (high - low) / 2;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            T res = func(mid);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;            <span class="keywordflow">if</span> (res == value)</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                <span class="keywordflow">return</span> mid;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (res &lt; value)</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                low = mid + 1;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            }</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                high = mid - 1;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            }</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        }</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160; </div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4682953080265083bdf5c32d94d64bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4682953080265083bdf5c32d94d64bbd">&#9670;&nbsp;</a></span>binary_tree_to_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;int, std::vector&lt;int&gt; &gt; hsc_snippets::binary_tree_to_adjacency_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a binary tree to an adjacency list representation. All node values in the binary tree must be unique. The adjacency list is bidirectional, meaning for each parent-child relation, both the parent's list contains the child and the child's list contains the parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the binary tree. If the tree is empty (nullptr), the function returns an empty adjacency list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered_map where keys are node values and values are vectors of integers representing the node values of adjacent nodes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="binary__tree_8hpp_source.html#l00158">158</a> of file <a class="el" href="binary__tree_8hpp_source.html">binary_tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    {</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keyword">auto</span> adjacencyList = std::unordered_map&lt;int, std::vector&lt;int&gt;&gt;{};</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <span class="keywordflow">if</span> (root == <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            <span class="keywordflow">return</span> adjacencyList;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        }</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="keyword">auto</span> q = std::queue&lt;TreeNode *&gt;{};</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        q.push(root);</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keywordflow">while</span> (!q.empty())</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            <span class="keyword">auto</span> node = q.front();</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            q.pop();</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;            <span class="keywordflow">if</span> (node-&gt;left != <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            {</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                adjacencyList[node-&gt;left-&gt;val].push_back(node-&gt;val);</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                adjacencyList[node-&gt;val].push_back(node-&gt;left-&gt;val);</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                q.push(node-&gt;left);</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            }</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            <span class="keywordflow">if</span> (node-&gt;right != <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            {</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                adjacencyList[node-&gt;right-&gt;val].push_back(node-&gt;val);</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                adjacencyList[node-&gt;val].push_back(node-&gt;right-&gt;val);</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                q.push(node-&gt;right);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            }</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        }</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160; </div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordflow">return</span> adjacencyList;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a81e92cf1e38f63173173f47971670eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e92cf1e38f63173173f47971670eec">&#9670;&nbsp;</a></span>breadth_first_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::breadth_first_search </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; int, std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacency_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int, int)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a breadth-first search (BFS) on an undirected graph starting from a given root node. It uses a queue to explore nodes level by level, ensuring each node is visited exactly once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacency_list</td><td>The graph represented as an adjacency list, where each key-value pair corresponds to a node and its list of adjacent nodes. </td></tr>
    <tr><td class="paramname">root</td><td>The starting node for the BFS. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to be called for each visited node. It takes the distance from the root and the node itself as arguments. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="graph_8hpp_source.html#l00164">164</a> of file <a class="el" href="graph_8hpp_source.html">graph.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keyword">auto</span> visited = std::unordered_set&lt;int&gt;{};</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keyword">auto</span> q = std::queue&lt;std::pair&lt;int, int&gt;&gt;{}; <span class="comment">// Regular queue for BFS</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        q.emplace(0, root);                         <span class="comment">// Initialize queue with root node at distance 0</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keywordflow">while</span> (!q.empty())</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        {</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;            <span class="keyword">auto</span> [dist, node] = q.front(); <span class="comment">// Extract node at the front of the queue</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            q.pop();</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160; </div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            <span class="keywordflow">if</span> (visited.contains(node)) <span class="comment">// Skip if node has already been visited</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            {</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            }</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            visited.insert(node); <span class="comment">// Mark current node as visited</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160; </div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;            callback(dist, node); <span class="comment">// Invoke callback for the current node</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160; </div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> adjacent_node : adjacency_list[node]) <span class="comment">// Explore adjacent nodes</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                <span class="keywordflow">if</span> (visited.contains(adjacent_node)) <span class="comment">// Skip if adjacent node has already been visited</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                {</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                    <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                }</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                q.emplace(dist + 1, adjacent_node); <span class="comment">// Enqueue adjacent node with distance incremented by 1</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            }</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        }</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7a0a80e48e879d3c68dda0b5a8055afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0a80e48e879d3c68dda0b5a8055afa">&#9670;&nbsp;</a></span>breadth_first_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::breadth_first_search </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacency_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int, int)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a breadth-first search (BFS) traversal on a graph represented by an adjacency list, starting from the specified root node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacency_list</td><td>The adjacency list representation of the graph. Each element represents a node and contains the indices of its adjacent nodes. </td></tr>
    <tr><td class="paramname">root</td><td>The index of the root node from which the BFS traversal starts. </td></tr>
    <tr><td class="paramname">callback</td><td>A callback function invoked for each visited node during the BFS traversal. It takes two parameters: the distance of the current node from the root and the index of the current node. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="graph_8hpp_source.html#l00126">126</a> of file <a class="el" href="graph_8hpp_source.html">graph.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keyword">auto</span> visited = std::unordered_set&lt;int&gt;{};</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <span class="keyword">auto</span> q = std::queue&lt;std::pair&lt;int, int&gt;&gt;{}; <span class="comment">// Regular queue for BFS</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        q.emplace(0, root);                         <span class="comment">// Initialize queue with root node at distance 0</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        <span class="keywordflow">while</span> (!q.empty())</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        {</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            <span class="keyword">auto</span> [dist, node] = q.front(); <span class="comment">// Extract node at the front of the queue</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;            q.pop();</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160; </div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;            <span class="keywordflow">if</span> (visited.contains(node)) <span class="comment">// Skip if node has already been visited</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;            {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            }</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            visited.insert(node); <span class="comment">// Mark current node as visited</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160; </div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;            callback(dist, node); <span class="comment">// Invoke callback for the current node</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160; </div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> adjacent_node : adjacency_list[node]) <span class="comment">// Explore adjacent nodes</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            {</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                <span class="keywordflow">if</span> (visited.contains(adjacent_node)) <span class="comment">// Skip if adjacent node has already been visited</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                {</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                    <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                }</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                q.emplace(dist + 1, adjacent_node); <span class="comment">// Enqueue adjacent node with distance incremented by 1</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            }</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        }</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="graph_8hpp_source.html#l00350">findConnectedComponents()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_a7a0a80e48e879d3c68dda0b5a8055afa_icgraph.png" border="0" usemap="#anamespacehsc__snippets_a7a0a80e48e879d3c68dda0b5a8055afa_icgraph" alt=""/></div>
<map name="anamespacehsc__snippets_a7a0a80e48e879d3c68dda0b5a8055afa_icgraph" id="anamespacehsc__snippets_a7a0a80e48e879d3c68dda0b5a8055afa_icgraph">
<area shape="rect" title=" " alt="" coords="260,5,424,47"/>
<area shape="rect" href="namespacehsc__snippets.html#aa308cca2fd4701c87f2800f67989f733" title=" " alt="" coords="5,5,212,47"/>
</map>
</div>

</div>
</div>
<a id="a2f76e1d412f83567b03ef84aa374878a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f76e1d412f83567b03ef84aa374878a">&#9670;&nbsp;</a></span>containsInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::containsInRange </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sorted__utils_8hpp_source.html#l00024">24</a> of file <a class="el" href="sorted__utils_8hpp_source.html">sorted_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        <span class="keywordflow">if</span> (vec.empty() || start &gt;= end)</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        }</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160; </div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        <span class="comment">// Lower bound of the range</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        <span class="keyword">auto</span> lower = std::lower_bound(vec.begin(), vec.end(), start);</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160; </div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="comment">// Check if the lower bound is not beyond the vector and less than &#39;end&#39;</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        <span class="keywordflow">if</span> (lower != vec.end() &amp;&amp; *lower &lt; end)</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        {</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        }</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160; </div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a429782e4ffeba328dbfc0339166d667c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429782e4ffeba328dbfc0339166d667c">&#9670;&nbsp;</a></span>delete_binary_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::delete_binary_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all nodes of a binary tree to free memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the binary tree. If the pointer is nullptr, the function does nothing, safely handling the case of an empty tree or reaching the end of a branch. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="binary__tree_8hpp_source.html#l00079">79</a> of file <a class="el" href="binary__tree_8hpp_source.html">binary_tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    {</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        <span class="keywordflow">if</span> (root == <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <a class="code" href="namespacehsc__snippets.html#a429782e4ffeba328dbfc0339166d667c">delete_binary_tree</a>(root-&gt;left);</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <a class="code" href="namespacehsc__snippets.html#a429782e4ffeba328dbfc0339166d667c">delete_binary_tree</a>(root-&gt;right);</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="keyword">delete</span> root;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_a429782e4ffeba328dbfc0339166d667c"><div class="ttname"><a href="namespacehsc__snippets.html#a429782e4ffeba328dbfc0339166d667c">hsc_snippets::delete_binary_tree</a></div><div class="ttdeci">void delete_binary_tree(TreeNode *root)</div><div class="ttdef"><b>Definition:</b> <a href="binary__tree_8hpp_source.html#l00079">binary_tree.hpp:79</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="binary__tree_8hpp_source.html#l00016">hsc_snippets::TreeNode::left</a>, and <a class="el" href="binary__tree_8hpp_source.html#l00017">hsc_snippets::TreeNode::right</a>.</p>

</div>
</div>
<a id="a6fabbb1930246a813ae92741a8d16b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fabbb1930246a813ae92741a8d16b93">&#9670;&nbsp;</a></span>depth_first_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::depth_first_search </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacency_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int, int)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a depth-first search (DFS) traversal on a graph represented by an adjacency list, starting from the specified root node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacency_list</td><td>The adjacency list representation of the graph. Each element represents a node and contains the indices of its adjacent nodes. </td></tr>
    <tr><td class="paramname">root</td><td>The index of the root node from which the DFS traversal starts. </td></tr>
    <tr><td class="paramname">callback</td><td>A callback function invoked for each visited node during the DFS traversal. It takes two parameters: the distance of the current node from the root and the index of the current node. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="graph_8hpp_source.html#l00204">204</a> of file <a class="el" href="graph_8hpp_source.html">graph.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    {</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        <span class="keyword">auto</span> visited = std::unordered_set&lt;int&gt;{};</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        <span class="keyword">auto</span> stack = std::stack&lt;std::pair&lt;int, int&gt;&gt;{}; <span class="comment">// Stack for DFS</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        stack.emplace(0, root);                         <span class="comment">// Initialize stack with root node at distance 0</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        <span class="keywordflow">while</span> (!stack.empty())</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        {</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            <span class="keyword">auto</span> [dist, node] = stack.top(); <span class="comment">// Extract node at the top of the stack</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            stack.pop();</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160; </div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            <span class="keywordflow">if</span> (visited.contains(node)) <span class="comment">// Skip if node has already been visited</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;            {</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;            }</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            visited.insert(node); <span class="comment">// Mark current node as visited</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160; </div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            callback(dist, node); <span class="comment">// Invoke callback for the current node</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160; </div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span> adjacent_node : adjacency_list[node]) <span class="comment">// Explore adjacent nodes</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;            {</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                <span class="keywordflow">if</span> (visited.contains(adjacent_node)) <span class="comment">// Skip if adjacent node has already been visited</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                {</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                    <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                }</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                stack.emplace(dist + 1, adjacent_node); <span class="comment">// Push adjacent node with distance incremented by 1</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            }</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        }</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8bebf773bd423b05199ae6cadd87702e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bebf773bd423b05199ae6cadd87702e">&#9670;&nbsp;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::dijkstra </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::pair&lt; int, int &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacency_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dijkstra's algorithm to find the shortest path from source to destination in a graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of vertices in the graph. </td></tr>
    <tr><td class="paramname">adjacency_list</td><td>Adjacency list representation of the graph where each element is a pair representing an edge (to, weight). </td></tr>
    <tr><td class="paramname">src</td><td>Source vertex. </td></tr>
    <tr><td class="paramname">dst</td><td>Destination vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shortest distance from source to destination. Returns -1 if no path exists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_8hpp_source.html#l00242">242</a> of file <a class="el" href="graph_8hpp_source.html">graph.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160; </div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        std::vector&lt;int&gt; dist(n, std::numeric_limits&lt;int&gt;::max());</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt;&gt;, std::greater&lt;&gt;&gt; pq;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160; </div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        dist[src] = 0;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        pq.emplace(0, src);</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160; </div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <span class="keywordflow">while</span> (!pq.empty())</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        {</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            <span class="keywordtype">int</span> u = pq.top().second;</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            pq.pop();</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160; </div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;neighbor : adjacency_list[u])</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            {</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                <span class="keywordtype">int</span> v = neighbor.first;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                <span class="keywordtype">int</span> weight = neighbor.second;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160; </div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                <span class="keywordflow">if</span> (dist[v] &gt; dist[u] + weight)</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                {</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                    dist[v] = dist[u] + weight;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                    pq.emplace(dist[v], v);</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                }</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            }</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        }</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160; </div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        <span class="keywordflow">return</span> dist[dst] == std::numeric_limits&lt;int&gt;::max() ? -1 : dist[dst];</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5045aafbb3add6fd38bd87a578795bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5045aafbb3add6fd38bd87a578795bee">&#9670;&nbsp;</a></span>find_euler_path_directed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; hsc_snippets::find_euler_path_directed </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds an Eulerian path or circuit in a directed graph.</p>
<p>This function assumes that the given graph has an Eulerian path or circuit, which means the graph is connected and either: </p>
<ul>
<li>All vertices have equal in-degrees and out-degrees (Eulerian circuit), or </li>
</ul>
<ul>
<li>All but two vertices have equal in-degrees and out-degrees, and one of those two vertices has out-degree = in-degree + 1 (start), and the other has in-degree = out-degree + 1 (end) (Eulerian path).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>A vector of pairs representing directed edges in the graph. Each pair (a, b) represents a directed edge from a to b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector representing the Eulerian path or circuit as a sequence of vertex indices. If a circuit exists, the path can start from any vertex in the circuit. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_8hpp_source.html#l00289">289</a> of file <a class="el" href="graph_8hpp_source.html">graph.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    {</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        std::unordered_map&lt;int, std::stack&lt;int&gt;&gt; adj;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        std::unordered_map&lt;int, int&gt; in;</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        std::unordered_map&lt;int, int&gt; out;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;edge : edges)</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        {</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            <span class="keywordtype">int</span> from = edge[0];</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            <span class="keywordtype">int</span> to = edge[1];</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            adj[from].push(to);</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            in[to] += 1;</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            out[from] += 1;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        }</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160; </div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordtype">int</span> start = adj.begin()-&gt;first; <span class="comment">// Default start node</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;p : adj)</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        {</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            <span class="keywordflow">if</span> (out[p.first] - in[p.first] == 1)</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            { <span class="comment">// Find the actual start node for Euler Path</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                start = p.first;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            }</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        }</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160; </div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        std::stack&lt;int&gt; current_path;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        std::vector&lt;int&gt; circuit;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        current_path.push(start);</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160; </div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        <span class="keywordflow">while</span> (!current_path.empty())</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        {</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;            <span class="keywordtype">int</span> current_vertex = current_path.top();</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160; </div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            <span class="keywordflow">if</span> (!adj[current_vertex].empty())</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            { <span class="comment">// If current vertex has neighbors</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                <span class="keywordtype">int</span> next_vertex = adj[current_vertex].top();</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                adj[current_vertex].pop();      <span class="comment">// Remove the edge from current to next</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                current_path.push(next_vertex); <span class="comment">// Move to next vertex</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            }</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;            {                                      <span class="comment">// Backtrack</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                circuit.push_back(current_vertex); <span class="comment">// Add to Euler circuit/path</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                current_path.pop();                <span class="comment">// Remove the vertex as it has no more neighbors</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;            }</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        }</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160; </div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        <span class="comment">// Reverse the circuit to get the Euler path</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;        std::reverse(circuit.begin(), circuit.end());</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160; </div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keywordflow">return</span> circuit;</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa308cca2fd4701c87f2800f67989f733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa308cca2fd4701c87f2800f67989f733">&#9670;&nbsp;</a></span>findConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;int&gt; &gt; hsc_snippets::findConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; int, std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds and returns all connected components in an undirected graph. It iterates over all nodes, using a BFS starting from each unvisited node to discover all nodes in the same connected component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adj</td><td>The graph represented as an adjacency list, where keys are node identifiers and values are lists of adjacent nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors, where each inner vector represents a connected component of the graph and contains all node identifiers within that component. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_8hpp_source.html#l00350">350</a> of file <a class="el" href="graph_8hpp_source.html">graph.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    {</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        std::unordered_map&lt;int, bool&gt; visited{}; <span class="comment">// Tracks whether each node has been visited</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;p : adj)</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        {</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;            visited.insert({p.first, <span class="keyword">false</span>}); <span class="comment">// Initialize all nodes as unvisited</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        }</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160; </div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        std::vector&lt;std::vector&lt;int&gt;&gt; connectedComponents; <span class="comment">// Stores the connected components</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160; </div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;p : visited)</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        {</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;            <span class="keywordflow">if</span> (!p.second)</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;            {                               <span class="comment">// For each unvisited node</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                std::vector&lt;int&gt; component; <span class="comment">// Stores the current component&#39;s nodes</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                <a class="code" href="namespacehsc__snippets.html#a81e92cf1e38f63173173f47971670eec">breadth_first_search</a>(adj, p.first, [&amp;visited, &amp;component](<span class="keywordtype">int</span>, <span class="keywordtype">int</span> node)</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                                     {</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                                         visited[node] = true;      <span class="comment">// Mark the node as visited</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                                         component.push_back(node); <span class="comment">// Add the node to the current component</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                                     });                            <span class="comment">// Perform BFS to find all nodes in this component</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                connectedComponents.push_back(component);           <span class="comment">// Add the current component to the list</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;            }</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        }</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160; </div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        <span class="keywordflow">return</span> connectedComponents; <span class="comment">// Return all found connected components</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_a81e92cf1e38f63173173f47971670eec"><div class="ttname"><a href="namespacehsc__snippets.html#a81e92cf1e38f63173173f47971670eec">hsc_snippets::breadth_first_search</a></div><div class="ttdeci">void breadth_first_search(std::unordered_map&lt; int, std::vector&lt; int &gt;&gt; &amp;adjacency_list, int root, std::function&lt; void(int, int)&gt; callback)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8hpp_source.html#l00164">graph.hpp:164</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="graph_8hpp_source.html#l00126">breadth_first_search()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_aa308cca2fd4701c87f2800f67989f733_cgraph.png" border="0" usemap="#anamespacehsc__snippets_aa308cca2fd4701c87f2800f67989f733_cgraph" alt=""/></div>
<map name="anamespacehsc__snippets_aa308cca2fd4701c87f2800f67989f733_cgraph" id="anamespacehsc__snippets_aa308cca2fd4701c87f2800f67989f733_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,212,47"/>
<area shape="rect" href="namespacehsc__snippets.html#a7a0a80e48e879d3c68dda0b5a8055afa" title=" " alt="" coords="260,5,424,47"/>
</map>
</div>

</div>
</div>
<a id="afff61e6f2efed27bc4bbb2a2c6a44328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff61e6f2efed27bc4bbb2a2c6a44328">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::gcd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A numeric type that should be an integral type (e.g., int, long). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number. </td></tr>
    <tr><td class="paramname">b</td><td>The second number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest common divisor of a and b. </dd></dl>

<p class="definition">Definition at line <a class="el" href="number__utils_8hpp_source.html#l00063">63</a> of file <a class="el" href="number__utils_8hpp_source.html">number_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        <span class="keywordflow">while</span> (b != 0)</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        {</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            T temp = b;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            b = a % b;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            a = temp;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        }</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keywordflow">return</span> a; <span class="comment">// When b becomes 0, a contains the gcd</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="number__utils_8hpp_source.html#l00084">lcm()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_afff61e6f2efed27bc4bbb2a2c6a44328_icgraph.png" border="0" usemap="#anamespacehsc__snippets_afff61e6f2efed27bc4bbb2a2c6a44328_icgraph" alt=""/></div>
<map name="anamespacehsc__snippets_afff61e6f2efed27bc4bbb2a2c6a44328_icgraph" id="anamespacehsc__snippets_afff61e6f2efed27bc4bbb2a2c6a44328_icgraph">
<area shape="rect" title=" " alt="" coords="192,5,329,32"/>
<area shape="rect" href="namespacehsc__snippets.html#a9d31a87aa5ed5297257e6daea49a4c72" title=" " alt="" coords="5,5,144,32"/>
</map>
</div>

</div>
</div>
<a id="a26cce75b709a679ebc99a4abcdbbd7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cce75b709a679ebc99a4abcdbbd7bd">&#9670;&nbsp;</a></span>get_binary_tree_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::get_binary_tree_depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the depth of a binary tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the binary tree. If the tree is empty (nullptr), the depth is considered to be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The depth of the binary tree as an integer. An empty tree has a depth of 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="binary__tree_8hpp_source.html#l00095">95</a> of file <a class="el" href="binary__tree_8hpp_source.html">binary_tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordflow">if</span> (root == <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        <span class="keywordtype">int</span> depth = 1;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        depth = std::max(depth, <a class="code" href="namespacehsc__snippets.html#a26cce75b709a679ebc99a4abcdbbd7bd">get_binary_tree_depth</a>(root-&gt;left) + 1);</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        depth = std::max(depth, <a class="code" href="namespacehsc__snippets.html#a26cce75b709a679ebc99a4abcdbbd7bd">get_binary_tree_depth</a>(root-&gt;right) + 1);</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="keywordflow">return</span> depth;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_a26cce75b709a679ebc99a4abcdbbd7bd"><div class="ttname"><a href="namespacehsc__snippets.html#a26cce75b709a679ebc99a4abcdbbd7bd">hsc_snippets::get_binary_tree_depth</a></div><div class="ttdeci">int get_binary_tree_depth(TreeNode *root)</div><div class="ttdef"><b>Definition:</b> <a href="binary__tree_8hpp_source.html#l00095">binary_tree.hpp:95</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="binary__tree_8hpp_source.html#l00016">hsc_snippets::TreeNode::left</a>, and <a class="el" href="binary__tree_8hpp_source.html#l00017">hsc_snippets::TreeNode::right</a>.</p>

</div>
</div>
<a id="a9919b9e521c5513278a973e42a1bbf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9919b9e521c5513278a973e42a1bbf42">&#9670;&nbsp;</a></span>greaterThanAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanAll </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="varadic__numeric_8hpp_source.html#l00038">38</a> of file <a class="el" href="varadic__numeric_8hpp_source.html">varadic_numeric.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    {</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="keywordflow">return</span> x &gt; val;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="varadic__numeric_8hpp_source.html#l00043">greaterThanAll()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_a9919b9e521c5513278a973e42a1bbf42_icgraph.png" border="0" usemap="#anamespacehsc__snippets_a9919b9e521c5513278a973e42a1bbf42_icgraph" alt=""/></div>
<map name="anamespacehsc__snippets_a9919b9e521c5513278a973e42a1bbf42_icgraph" id="anamespacehsc__snippets_a9919b9e521c5513278a973e42a1bbf42_icgraph">
<area shape="rect" title=" " alt="" coords="264,5,475,32"/>
<area shape="rect" href="namespacehsc__snippets.html#aca360e3bd41a5aa9aa1873147e5bc823" title=" " alt="" coords="5,5,216,32"/>
</map>
</div>

</div>
</div>
<a id="aca360e3bd41a5aa9aa1873147e5bc823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca360e3bd41a5aa9aa1873147e5bc823">&#9670;&nbsp;</a></span>greaterThanAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanAll </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="varadic__numeric_8hpp_source.html#l00043">43</a> of file <a class="el" href="varadic__numeric_8hpp_source.html">varadic_numeric.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    {</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        <span class="keywordflow">if</span> (!(x &gt; val))</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacehsc__snippets.html#aca360e3bd41a5aa9aa1873147e5bc823">greaterThanAll</a>(x, args...);</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_aca360e3bd41a5aa9aa1873147e5bc823"><div class="ttname"><a href="namespacehsc__snippets.html#aca360e3bd41a5aa9aa1873147e5bc823">hsc_snippets::greaterThanAll</a></div><div class="ttdeci">bool greaterThanAll(T x, T val, Args... args)</div><div class="ttdef"><b>Definition:</b> <a href="varadic__numeric_8hpp_source.html#l00043">varadic_numeric.hpp:43</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="varadic__numeric_8hpp_source.html#l00038">greaterThanAll()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_aca360e3bd41a5aa9aa1873147e5bc823_cgraph.png" border="0" usemap="#anamespacehsc__snippets_aca360e3bd41a5aa9aa1873147e5bc823_cgraph" alt=""/></div>
<map name="anamespacehsc__snippets_aca360e3bd41a5aa9aa1873147e5bc823_cgraph" id="anamespacehsc__snippets_aca360e3bd41a5aa9aa1873147e5bc823_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,216,32"/>
<area shape="rect" href="namespacehsc__snippets.html#a9919b9e521c5513278a973e42a1bbf42" title=" " alt="" coords="264,5,475,32"/>
</map>
</div>

</div>
</div>
<a id="a21c76cdee93b66ddae3fa5a37b42f19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c76cdee93b66ddae3fa5a37b42f19d">&#9670;&nbsp;</a></span>greaterThanOrEqualToAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="varadic__numeric_8hpp_source.html#l00051">51</a> of file <a class="el" href="varadic__numeric_8hpp_source.html">varadic_numeric.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="keywordflow">return</span> x &gt;= val;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="varadic__numeric_8hpp_source.html#l00056">greaterThanOrEqualToAll()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_a21c76cdee93b66ddae3fa5a37b42f19d_icgraph.png" border="0" usemap="#anamespacehsc__snippets_a21c76cdee93b66ddae3fa5a37b42f19d_icgraph" alt=""/></div>
<map name="anamespacehsc__snippets_a21c76cdee93b66ddae3fa5a37b42f19d_icgraph" id="anamespacehsc__snippets_a21c76cdee93b66ddae3fa5a37b42f19d_icgraph">
<area shape="rect" title=" " alt="" coords="247,5,440,47"/>
<area shape="rect" href="namespacehsc__snippets.html#ae97854002bbec586ad6d0a52ab4315e3" title=" " alt="" coords="5,5,199,47"/>
</map>
</div>

</div>
</div>
<a id="ae97854002bbec586ad6d0a52ab4315e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97854002bbec586ad6d0a52ab4315e3">&#9670;&nbsp;</a></span>greaterThanOrEqualToAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::greaterThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="varadic__numeric_8hpp_source.html#l00056">56</a> of file <a class="el" href="varadic__numeric_8hpp_source.html">varadic_numeric.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    {</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        <span class="keywordflow">if</span> (!(x &gt;= val))</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacehsc__snippets.html#ae97854002bbec586ad6d0a52ab4315e3">greaterThanOrEqualToAll</a>(x, args...);</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_ae97854002bbec586ad6d0a52ab4315e3"><div class="ttname"><a href="namespacehsc__snippets.html#ae97854002bbec586ad6d0a52ab4315e3">hsc_snippets::greaterThanOrEqualToAll</a></div><div class="ttdeci">bool greaterThanOrEqualToAll(T x, T val, Args... args)</div><div class="ttdef"><b>Definition:</b> <a href="varadic__numeric_8hpp_source.html#l00056">varadic_numeric.hpp:56</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="varadic__numeric_8hpp_source.html#l00051">greaterThanOrEqualToAll()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_ae97854002bbec586ad6d0a52ab4315e3_cgraph.png" border="0" usemap="#anamespacehsc__snippets_ae97854002bbec586ad6d0a52ab4315e3_cgraph" alt=""/></div>
<map name="anamespacehsc__snippets_ae97854002bbec586ad6d0a52ab4315e3_cgraph" id="anamespacehsc__snippets_ae97854002bbec586ad6d0a52ab4315e3_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,199,47"/>
<area shape="rect" href="namespacehsc__snippets.html#a21c76cdee93b66ddae3fa5a37b42f19d" title=" " alt="" coords="247,5,440,47"/>
</map>
</div>

</div>
</div>
<a id="ac7f93655a4a72d10c318c290783a2bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f93655a4a72d10c318c290783a2bdc">&#9670;&nbsp;</a></span>greatest_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::integral I = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I hsc_snippets::greatest_index </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the greatest index in a non-decreasing array where the function applied to the index returns a value less than or equal to the specified value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value against which the function's results are compared. </td></tr>
    <tr><td class="paramname">I</td><td>The integral type of the index, defaulting to int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>The lower bound of the search range (inclusive). </td></tr>
    <tr><td class="paramname">high</td><td>The upper bound of the search range (inclusive). </td></tr>
    <tr><td class="paramname">value</td><td>The value to compare against the function's results. </td></tr>
    <tr><td class="paramname">func</td><td>The function to apply to each index, expected to return non-decreasing values for the range [low, high]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest index for which func(index) &lt;= value, or -1 if no such index exists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sorted__utils_8hpp_source.html#l00085">85</a> of file <a class="el" href="sorted__utils_8hpp_source.html">sorted_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        I ans = -1; <span class="comment">// Initialize answer to -1 to indicate no valid index found yet</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keywordflow">while</span> (low &lt;= high)</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        {</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            I mid = low + (high - low) / 2; <span class="comment">// Calculate the mid-point of the current search range</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;            T res = func(mid);              <span class="comment">// Evaluate the function at the mid-point</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            <span class="keywordflow">if</span> (res &lt;= value)</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            {</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                ans = mid;     <span class="comment">// Update answer since res is less than or equal to value</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                low = mid + 1; <span class="comment">// Narrow the search to the right half to find the greatest index</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            }</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;                high = mid - 1; <span class="comment">// Narrow the search to the left half since res is greater than value</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            }</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        }</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160; </div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="keywordflow">return</span> ans; <span class="comment">// Return the found index or -1 if no such index exists</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6c82b125272d02d5cdaa2169f225f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c82b125272d02d5cdaa2169f225f85">&#9670;&nbsp;</a></span>inorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::inorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In-order traversal of a binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node of the binary tree. </td></tr>
    <tr><td class="paramname">func</td><td>Function to process each node's value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="binary__tree_8hpp_source.html#l00110">110</a> of file <a class="el" href="binary__tree_8hpp_source.html">binary_tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    {</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">if</span> (root == <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <a class="code" href="namespacehsc__snippets.html#ac6c82b125272d02d5cdaa2169f225f85">inorder</a>(root-&gt;left, func);</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        func(root-&gt;val);</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <a class="code" href="namespacehsc__snippets.html#ac6c82b125272d02d5cdaa2169f225f85">inorder</a>(root-&gt;right, func);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_ac6c82b125272d02d5cdaa2169f225f85"><div class="ttname"><a href="namespacehsc__snippets.html#ac6c82b125272d02d5cdaa2169f225f85">hsc_snippets::inorder</a></div><div class="ttdeci">void inorder(TreeNode *root, std::function&lt; void(int)&gt; func)</div><div class="ttdef"><b>Definition:</b> <a href="binary__tree_8hpp_source.html#l00110">binary_tree.hpp:110</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="binary__tree_8hpp_source.html#l00016">hsc_snippets::TreeNode::left</a>, <a class="el" href="binary__tree_8hpp_source.html#l00017">hsc_snippets::TreeNode::right</a>, and <a class="el" href="binary__tree_8hpp_source.html#l00015">hsc_snippets::TreeNode::val</a>.</p>

</div>
</div>
<a id="a1228660ec00e385121ef6171dc80d2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1228660ec00e385121ef6171dc80d2be">&#9670;&nbsp;</a></span>isPalindrome()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::isPalindrome </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a given string is a palindrome.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to check for palindromicity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 's' is a palindrome, False otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__utils_8hpp_source.html#l00097">97</a> of file <a class="el" href="string__utils_8hpp_source.html">string_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        assert(!s.empty());</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">int</span> n = s.size();</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n / 2; i++)</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        {</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            <span class="keywordflow">if</span> (s[i] != s[n - 1 - i])</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            {</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            }</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        }</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ada8b2ad5272145a4908355c6e64d194f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8b2ad5272145a4908355c6e64d194f">&#9670;&nbsp;</a></span>kmpSearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; hsc_snippets::kmpSearch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>txt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for all occurrences of a pattern within a text using the Knuth-Morris-Pratt (KMP) algorithm.</p>
<p>The KMP algorithm pre-processes the pattern to construct an array of longest proper prefixes which are also suffixes (LPS array). It then uses this LPS array to skip redundant comparisons when a mismatch occurs, thereby improving the search efficiency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pat</td><td>The pattern string to search for within the text. </td></tr>
    <tr><td class="paramname">txt</td><td>The text string in which to search for the pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the starting indices of all occurrences of 'pat' within 'txt'. </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__utils_8hpp_source.html#l00024">24</a> of file <a class="el" href="string__utils_8hpp_source.html">string_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        <span class="keywordtype">int</span> M = pat.size();</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        <span class="keywordtype">int</span> N = txt.size();</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <span class="comment">// Longest Prefix Suffix (lps) array</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        std::vector&lt;int&gt; lps(M);</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        std::vector&lt;int&gt; result;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        <span class="comment">// Preprocess the pattern</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="keywordtype">int</span> len = 0;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        lps[0] = 0; <span class="comment">// lps[0] is always 0</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <span class="keywordtype">int</span> i = 1;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="keywordflow">while</span> (i &lt; M)</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        {</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;            <span class="keywordflow">if</span> (pat[i] == pat[len])</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;            {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                len++;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                lps[i] = len;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                i++;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            }</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;            {</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                <span class="keywordflow">if</span> (len != 0)</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                {</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                    len = lps[len - 1];</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                }</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                    lps[i] = 0;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                    i++;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                }</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            }</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        }</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="comment">// Search the pattern in txt</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        i = 0;     <span class="comment">// index for txt[]</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keywordtype">int</span> j = 0; <span class="comment">// index for pat[]</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">while</span> (i &lt; N)</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        {</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            <span class="keywordflow">if</span> (pat[j] == txt[i])</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                j++;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                i++;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            }</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160; </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            <span class="keywordflow">if</span> (j == M)</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;            {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                result.push_back(i - j);</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                j = lps[j - 1];</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            }</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i &lt; N &amp;&amp; pat[j] != txt[i])</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            {</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                <span class="keywordflow">if</span> (j != 0)</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                {</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                    j = lps[j - 1];</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                }</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                    i = i + 1;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                }</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            }</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        }</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160; </div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9d31a87aa5ed5297257e6daea49a4c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d31a87aa5ed5297257e6daea49a4c72">&#9670;&nbsp;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::lcm </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the least common multiple (LCM) of two numbers using the formula: LCM(a, b) = (a * b) / GCD(a, b)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A numeric type that should be an integral type (e.g., int, long). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number. </td></tr>
    <tr><td class="paramname">b</td><td>The second number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The least common multiple of a and b. </dd></dl>

<p class="definition">Definition at line <a class="el" href="number__utils_8hpp_source.html#l00084">84</a> of file <a class="el" href="number__utils_8hpp_source.html">number_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <span class="keywordflow">return</span> (a * b) / <a class="code" href="namespacehsc__snippets.html#afff61e6f2efed27bc4bbb2a2c6a44328">gcd</a>(a, b);</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_afff61e6f2efed27bc4bbb2a2c6a44328"><div class="ttname"><a href="namespacehsc__snippets.html#afff61e6f2efed27bc4bbb2a2c6a44328">hsc_snippets::gcd</a></div><div class="ttdeci">T gcd(T a, T b)</div><div class="ttdef"><b>Definition:</b> <a href="number__utils_8hpp_source.html#l00063">number_utils.hpp:63</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="number__utils_8hpp_source.html#l00063">gcd()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_a9d31a87aa5ed5297257e6daea49a4c72_cgraph.png" border="0" usemap="#anamespacehsc__snippets_a9d31a87aa5ed5297257e6daea49a4c72_cgraph" alt=""/></div>
<map name="anamespacehsc__snippets_a9d31a87aa5ed5297257e6daea49a4c72_cgraph" id="anamespacehsc__snippets_a9d31a87aa5ed5297257e6daea49a4c72_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,144,32"/>
<area shape="rect" href="namespacehsc__snippets.html#afff61e6f2efed27bc4bbb2a2c6a44328" title=" " alt="" coords="192,5,329,32"/>
</map>
</div>

</div>
</div>
<a id="ac6691641b2d50eca1b2145da55c74f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6691641b2d50eca1b2145da55c74f1d">&#9670;&nbsp;</a></span>lessThanAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanAll </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="varadic__numeric_8hpp_source.html#l00012">12</a> of file <a class="el" href="varadic__numeric_8hpp_source.html">varadic_numeric.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        <span class="keywordflow">return</span> x &lt; val;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="varadic__numeric_8hpp_source.html#l00017">lessThanAll()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_ac6691641b2d50eca1b2145da55c74f1d_icgraph.png" border="0" usemap="#anamespacehsc__snippets_ac6691641b2d50eca1b2145da55c74f1d_icgraph" alt=""/></div>
<map name="anamespacehsc__snippets_ac6691641b2d50eca1b2145da55c74f1d_icgraph" id="anamespacehsc__snippets_ac6691641b2d50eca1b2145da55c74f1d_icgraph">
<area shape="rect" title=" " alt="" coords="243,5,432,32"/>
<area shape="rect" href="namespacehsc__snippets.html#ae5c0498b1070c4404daaaf087992758b" title=" " alt="" coords="5,5,195,32"/>
</map>
</div>

</div>
</div>
<a id="ae5c0498b1070c4404daaaf087992758b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c0498b1070c4404daaaf087992758b">&#9670;&nbsp;</a></span>lessThanAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanAll </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="varadic__numeric_8hpp_source.html#l00017">17</a> of file <a class="el" href="varadic__numeric_8hpp_source.html">varadic_numeric.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    {</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        <span class="keywordflow">if</span> (!(x &lt; val))</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacehsc__snippets.html#ae5c0498b1070c4404daaaf087992758b">lessThanAll</a>(x, args...);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_ae5c0498b1070c4404daaaf087992758b"><div class="ttname"><a href="namespacehsc__snippets.html#ae5c0498b1070c4404daaaf087992758b">hsc_snippets::lessThanAll</a></div><div class="ttdeci">bool lessThanAll(T x, T val, Args... args)</div><div class="ttdef"><b>Definition:</b> <a href="varadic__numeric_8hpp_source.html#l00017">varadic_numeric.hpp:17</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="varadic__numeric_8hpp_source.html#l00012">lessThanAll()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_ae5c0498b1070c4404daaaf087992758b_cgraph.png" border="0" usemap="#anamespacehsc__snippets_ae5c0498b1070c4404daaaf087992758b_cgraph" alt=""/></div>
<map name="anamespacehsc__snippets_ae5c0498b1070c4404daaaf087992758b_cgraph" id="anamespacehsc__snippets_ae5c0498b1070c4404daaaf087992758b_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,195,32"/>
<area shape="rect" href="namespacehsc__snippets.html#ac6691641b2d50eca1b2145da55c74f1d" title=" " alt="" coords="243,5,432,32"/>
</map>
</div>

</div>
</div>
<a id="a8f9c656f40560cd6141ff708c5937b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9c656f40560cd6141ff708c5937b89">&#9670;&nbsp;</a></span>lessThanOrEqualToAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="varadic__numeric_8hpp_source.html#l00025">25</a> of file <a class="el" href="varadic__numeric_8hpp_source.html">varadic_numeric.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    {</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        <span class="keywordflow">return</span> x &lt;= val;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="varadic__numeric_8hpp_source.html#l00030">lessThanOrEqualToAll()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_a8f9c656f40560cd6141ff708c5937b89_icgraph.png" border="0" usemap="#anamespacehsc__snippets_a8f9c656f40560cd6141ff708c5937b89_icgraph" alt=""/></div>
<map name="anamespacehsc__snippets_a8f9c656f40560cd6141ff708c5937b89_icgraph" id="anamespacehsc__snippets_a8f9c656f40560cd6141ff708c5937b89_icgraph">
<area shape="rect" title=" " alt="" coords="240,5,427,47"/>
<area shape="rect" href="namespacehsc__snippets.html#a0e874c9c2bfef67800a520d9ccf60805" title=" " alt="" coords="5,5,192,47"/>
</map>
</div>

</div>
</div>
<a id="a0e874c9c2bfef67800a520d9ccf60805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e874c9c2bfef67800a520d9ccf60805">&#9670;&nbsp;</a></span>lessThanOrEqualToAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hsc_snippets::lessThanOrEqualToAll </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="varadic__numeric_8hpp_source.html#l00030">30</a> of file <a class="el" href="varadic__numeric_8hpp_source.html">varadic_numeric.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    {</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        <span class="keywordflow">if</span> (!(x &lt;= val))</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespacehsc__snippets.html#a0e874c9c2bfef67800a520d9ccf60805">lessThanOrEqualToAll</a>(x, args...);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_a0e874c9c2bfef67800a520d9ccf60805"><div class="ttname"><a href="namespacehsc__snippets.html#a0e874c9c2bfef67800a520d9ccf60805">hsc_snippets::lessThanOrEqualToAll</a></div><div class="ttdeci">bool lessThanOrEqualToAll(T x, T val, Args... args)</div><div class="ttdef"><b>Definition:</b> <a href="varadic__numeric_8hpp_source.html#l00030">varadic_numeric.hpp:30</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="varadic__numeric_8hpp_source.html#l00025">lessThanOrEqualToAll()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_a0e874c9c2bfef67800a520d9ccf60805_cgraph.png" border="0" usemap="#anamespacehsc__snippets_a0e874c9c2bfef67800a520d9ccf60805_cgraph" alt=""/></div>
<map name="anamespacehsc__snippets_a0e874c9c2bfef67800a520d9ccf60805_cgraph" id="anamespacehsc__snippets_a0e874c9c2bfef67800a520d9ccf60805_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,192,47"/>
<area shape="rect" href="namespacehsc__snippets.html#a8f9c656f40560cd6141ff708c5937b89" title=" " alt="" coords="240,5,427,47"/>
</map>
</div>

</div>
</div>
<a id="ad8903642c515fa5c02500dce7f9bc9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8903642c515fa5c02500dce7f9bc9ef">&#9670;&nbsp;</a></span>make_unweighted_directed_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;int&gt; &gt; hsc_snippets::make_unweighted_directed_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an unweighted, directed adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains two integers: [from, to], denoting a directed edge from node 'from' to node 'to'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors representing the adjacency list of the graph. Each inner vector corresponds to a node, containing the indices of connected nodes (edges are unweighted in this representation). </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_8hpp_source.html#l00103">103</a> of file <a class="el" href="graph_8hpp_source.html">graph.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    {</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="keyword">auto</span> adjacency_list = std::vector&lt;std::vector&lt;int&gt;&gt;(n);</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;edge : edges)</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            <span class="keywordtype">int</span> from = edge[0];</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            <span class="keywordtype">int</span> to = edge[1];</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            adjacency_list[from].push_back(to);</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        }</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">return</span> adjacency_list;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a450c22d450def48b041a4dd2a3c6c333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450c22d450def48b041a4dd2a3c6c333">&#9670;&nbsp;</a></span>make_unweighted_undirected_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;int&gt; &gt; hsc_snippets::make_unweighted_undirected_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an unweighted, undirected adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains two integers: [from, to], denoting an edge from node 'from' to node 'to'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors representing the adjacency list of the graph. Each inner vector corresponds to a node, containing the indices of connected nodes (edges are unweighted in this representation). </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_8hpp_source.html#l00052">52</a> of file <a class="el" href="graph_8hpp_source.html">graph.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="keyword">auto</span> adjacency_list = std::vector&lt;std::vector&lt;int&gt;&gt;(n);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;edge : edges)</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            <span class="keywordtype">int</span> from = edge[0];</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            <span class="keywordtype">int</span> to = edge[1];</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            adjacency_list[from].push_back(to);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            adjacency_list[to].push_back(from); <span class="comment">// For undirected graph, edges are bidirectional</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        }</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">return</span> adjacency_list;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1c9476d9c908743ec404014de4cd50b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9476d9c908743ec404014de4cd50b6">&#9670;&nbsp;</a></span>make_weighted_directed_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; hsc_snippets::make_weighted_directed_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a weighted, directed adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains three integers: [from, to, weight], denoting a weighted edge from node 'from' to node 'to' with the given weight. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors of pairs representing the adjacency list of the graph. Each inner vector corresponds to a node, containing pairs of connected nodes and their respective edge weights. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_8hpp_source.html#l00027">27</a> of file <a class="el" href="graph_8hpp_source.html">graph.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    {</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <span class="keyword">auto</span> adjacency_list = std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt;(n);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;edge : edges)</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        {</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;            <span class="keywordtype">int</span> from = edge[0];</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;            <span class="keywordtype">int</span> to = edge[1];</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;            <span class="keywordtype">int</span> weight = edge[2];</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;            adjacency_list[from].emplace_back(to, weight);</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        }</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="keywordflow">return</span> adjacency_list;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f9fdcf9f5e89a3867abed30f840c883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9fdcf9f5e89a3867abed30f840c883">&#9670;&nbsp;</a></span>make_weighted_undirected_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt; &gt; &gt; hsc_snippets::make_weighted_undirected_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a weighted, undirected adjacency list representation of a graph from a given set of edges. Nodes are indexed from 0 to n-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">edges</td><td>A vector of vectors representing edges, where each inner vector contains three integers: [from, to, weight], denoting a weighted edge between node 'from' and node 'to' with the given weight. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vectors of pairs representing the adjacency list of the graph. Each inner vector corresponds to a node, containing pairs of connected nodes and their respective edge weights. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph_8hpp_source.html#l00077">77</a> of file <a class="el" href="graph_8hpp_source.html">graph.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    {</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="keyword">auto</span> adjacency_list = std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt;(n);</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;edge : edges)</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            <span class="keywordtype">int</span> from = edge[0];</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            <span class="keywordtype">int</span> to = edge[1];</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keywordtype">int</span> weight = edge[2];</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            adjacency_list[from].emplace_back(to, weight);</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            adjacency_list[to].emplace_back(from, weight); <span class="comment">// For undirected graph, edges are bidirectional</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        }</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keywordflow">return</span> adjacency_list;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c058184d3bf4b4028ac27888f891666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c058184d3bf4b4028ac27888f891666">&#9670;&nbsp;</a></span>modular_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int hsc_snippets::modular_add </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="modular__arithmetic_8hpp_source.html#l00012">12</a> of file <a class="el" href="modular__arithmetic_8hpp_source.html">modular_arithmetic.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        <span class="keyword">auto</span> a = <span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(x);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        <span class="keyword">auto</span> b = <span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(y);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        <span class="keyword">auto</span> c = (a + b) % <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(c);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="modular__arithmetic_8hpp_source.html#l00010">MODULO</a>.</p>

</div>
</div>
<a id="a69f0c52364cd0e82d19151f1d05aee8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f0c52364cd0e82d19151f1d05aee8c">&#9670;&nbsp;</a></span>modular_cube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int hsc_snippets::modular_cube </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="modular__arithmetic_8hpp_source.html#l00052">52</a> of file <a class="el" href="modular__arithmetic_8hpp_source.html">modular_arithmetic.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="keyword">auto</span> a = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(x);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keyword">auto</span> b = (a * a) % <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <span class="keyword">auto</span> c = (b * a) % <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(c);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="modular__arithmetic_8hpp_source.html#l00010">MODULO</a>.</p>

</div>
</div>
<a id="a36dc1f9c8622b338e040c3d0746ffa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36dc1f9c8622b338e040c3d0746ffa45">&#9670;&nbsp;</a></span>modular_multiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int hsc_snippets::modular_multiply </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="modular__arithmetic_8hpp_source.html#l00037">37</a> of file <a class="el" href="modular__arithmetic_8hpp_source.html">modular_arithmetic.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    {</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keyword">auto</span> a = <span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(x);</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="keyword">auto</span> b = <span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(y);</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        <span class="keyword">auto</span> c = (a * b) % <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(c);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="modular__arithmetic_8hpp_source.html#l00010">MODULO</a>.</p>

</div>
</div>
<a id="a72561173b55e31dc534d5f5612a52246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72561173b55e31dc534d5f5612a52246">&#9670;&nbsp;</a></span>modular_pow2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::modular_pow2 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>exponent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="modular__arithmetic_8hpp_source.html#l00061">61</a> of file <a class="el" href="modular__arithmetic_8hpp_source.html">modular_arithmetic.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        constexpr <span class="keywordtype">size_t</span> N = 25;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        constexpr <span class="keyword">auto</span> lookup{[]() constexpr</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                              {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                                  std::array&lt;int, N&gt; a{};</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                                  a[0] = 1;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                                  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; N; i++)</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                                  {</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                                      a[i] = a[i - 1] &lt;&lt; 1;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                                  }</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                                  <span class="keywordflow">return</span> a;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                              }()};</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <span class="keywordflow">if</span> (exponent &lt;= N)</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        {</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            <span class="keywordflow">return</span> lookup[exponent] % <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        }</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        <span class="keyword">auto</span> half_e = exponent &gt;&gt; 1;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="keyword">auto</span> tmp = <span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(<a class="code" href="namespacehsc__snippets.html#a72561173b55e31dc534d5f5612a52246">modular_pow2</a>(half_e));</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keyword">auto</span> m = (exponent &amp; 1);</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        <span class="keywordflow">return</span> ((tmp * tmp) &lt;&lt; m) % <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_a72561173b55e31dc534d5f5612a52246"><div class="ttname"><a href="namespacehsc__snippets.html#a72561173b55e31dc534d5f5612a52246">hsc_snippets::modular_pow2</a></div><div class="ttdeci">int modular_pow2(size_t exponent)</div><div class="ttdef"><b>Definition:</b> <a href="modular__arithmetic_8hpp_source.html#l00061">modular_arithmetic.hpp:61</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="modular__arithmetic_8hpp_source.html#l00010">MODULO</a>.</p>

</div>
</div>
<a id="ab24c9c4d4245ec401fd40ecb1a12c1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24c9c4d4245ec401fd40ecb1a12c1b6">&#9670;&nbsp;</a></span>modular_square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int hsc_snippets::modular_square </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="modular__arithmetic_8hpp_source.html#l00045">45</a> of file <a class="el" href="modular__arithmetic_8hpp_source.html">modular_arithmetic.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    {</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <span class="keyword">auto</span> a = <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(x);</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <span class="keyword">auto</span> b = (a * a) % <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(b);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="modular__arithmetic_8hpp_source.html#l00010">MODULO</a>.</p>

</div>
</div>
<a id="af5b88bd1961aeceb11486a737609e862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b88bd1961aeceb11486a737609e862">&#9670;&nbsp;</a></span>modular_substract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int hsc_snippets::modular_substract </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="modular__arithmetic_8hpp_source.html#l00027">27</a> of file <a class="el" href="modular__arithmetic_8hpp_source.html">modular_arithmetic.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    {</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <span class="keyword">auto</span> a = <span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(x);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        <span class="keyword">auto</span> b = <span class="keyword">static_cast&lt;</span>std::int64_t<span class="keyword">&gt;</span>(y);</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        <span class="keyword">auto</span> c = (a - b);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        c = c % <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        c = (c + <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>) % <a class="code" href="namespacehsc__snippets.html#a218d0181825bcf526ca9e5c24f6aab06">MODULO</a>;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(c);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="modular__arithmetic_8hpp_source.html#l00010">MODULO</a>.</p>

</div>
</div>
<a id="a812f513d66e4108139de15d335e9cbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812f513d66e4108139de15d335e9cbf3">&#9670;&nbsp;</a></span>new_binary_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a>* hsc_snippets::new_binary_tree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::optional&lt; int &gt;&gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a binary tree from a vector of optional integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A vector of std::optional&lt;int&gt;, where each element represents a potential node in the binary tree. An std::nullopt value indicates the absence of a node at that position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the root node of the newly constructed binary tree. Returns nullptr if the input vector is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="binary__tree_8hpp_source.html#l00031">31</a> of file <a class="el" href="binary__tree_8hpp_source.html">binary_tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        <span class="keywordflow">if</span> (v.empty())</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        }</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span> n = v.size();</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160; </div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        assert(v[0].has_value());</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160; </div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(v[0].value());</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        <span class="keyword">auto</span> q = std::queue&lt;TreeNode *&gt;{};</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        q.push(root);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        <span class="keywordtype">int</span> i = 1;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160; </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <span class="keywordflow">while</span> (i &lt; n)</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        {</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;            <span class="keyword">auto</span> node = q.front();</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;            q.pop();</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            <span class="keywordflow">if</span> (v[i].has_value())</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;            {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                node-&gt;left = <span class="keyword">new</span> TreeNode(v[i].value());</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                q.push(node-&gt;left);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;            }</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            i += 1;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            <span class="keywordflow">if</span> (i &gt;= n)</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            }</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            <span class="keywordflow">if</span> (v[i].has_value())</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                node-&gt;right = <span class="keyword">new</span> TreeNode(v[i].value());</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                q.push(node-&gt;right);</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            }</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            i += 1;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        }</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160; </div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <span class="keywordflow">return</span> root;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4827ed3c09b534429c5feffed16809c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4827ed3c09b534429c5feffed16809c6">&#9670;&nbsp;</a></span>nextGreaterElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; hsc_snippets::nextGreaterElement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; T()&gt;&#160;</td>
          <td class="paramname"><em>no_greater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the next greater element for each element in a sequence. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements in the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nums</td><td>The sequence of elements. </td></tr>
    <tr><td class="paramname">no_greater</td><td>Function to call when no greater element is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the next greater element for each element in <code>nums</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="monotonic__stack_8hpp_source.html#l00077">77</a> of file <a class="el" href="monotonic__stack_8hpp_source.html">monotonic_stack.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    {</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        std::vector&lt;T&gt; result{};</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        result.reserve(nums.size());</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        MonotonicDecreasingStack&lt;T&gt; decreasingStack;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> num : nums)</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        {</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keyword">auto</span> tmp = decreasingStack.push(num);</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            <span class="keywordflow">if</span> (!tmp.has_value())</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                result.push_back(no_greater());</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            }</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            {</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                result.push_back(tmp.value());</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            }</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        }</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160; </div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="monotonic__stack_8hpp_source.html#l00029">hsc_snippets::MonotonicStack&lt; T, Comparator &gt;::push()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_a4827ed3c09b534429c5feffed16809c6_cgraph.png" border="0" usemap="#anamespacehsc__snippets_a4827ed3c09b534429c5feffed16809c6_cgraph" alt=""/></div>
<map name="anamespacehsc__snippets_a4827ed3c09b534429c5feffed16809c6_cgraph" id="anamespacehsc__snippets_a4827ed3c09b534429c5feffed16809c6_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,197,47"/>
<area shape="rect" href="classhsc__snippets_1_1_monotonic_stack.html#a6e43a7510961d404844d4b3a032e2f4c" title=" " alt="" coords="245,5,464,47"/>
</map>
</div>

</div>
</div>
<a id="a9dc8f948cda1de6cbdb67bf6680d87f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc8f948cda1de6cbdb67bf6680d87f9">&#9670;&nbsp;</a></span>numBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::numBits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of bits required to represent an integer in binary. For negative numbers, it returns the number of bits in the type (e.g., 32 for int), assuming two's complement representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the input number, constrained to integral types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The input number whose binary bit count is to be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bits required to represent num in binary, or the bit size of T for negative numbers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="number__utils_8hpp_source.html#l00039">39</a> of file <a class="el" href="number__utils_8hpp_source.html">number_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        <span class="keywordflow">if</span> (num &lt; 0)</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(T) &lt;&lt; 3;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        }</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        <span class="keywordtype">int</span> cnt = 0;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keywordflow">while</span> (num != 0)</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        {</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;            cnt += 1;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;            num = num &gt;&gt; 1;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        }</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="keywordflow">return</span> cnt;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a21faa054d1afffbd2d869a99a54209de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21faa054d1afffbd2d869a99a54209de">&#9670;&nbsp;</a></span>numDigits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::numDigits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of digits in the decimal representation of an integer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the input number, constrained to integral types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The input number whose number of decimal digits is to be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of digits in the decimal representation of num. </dd></dl>

<p class="definition">Definition at line <a class="el" href="number__utils_8hpp_source.html#l00018">18</a> of file <a class="el" href="number__utils_8hpp_source.html">number_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    {</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        <span class="keywordtype">int</span> cnt = 0;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        <span class="keywordflow">while</span> (num != 0)</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        {</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;            cnt += 1;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;            num /= 10;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        }</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        <span class="keywordflow">return</span> cnt;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a770cc063eb04b7231b755c72383511d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770cc063eb04b7231b755c72383511d3">&#9670;&nbsp;</a></span>numOfGreaterElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::totally_ordered T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int hsc_snippets::numOfGreaterElements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sorted__utils_8hpp_source.html#l00010">10</a> of file <a class="el" href="sorted__utils_8hpp_source.html">sorted_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        <span class="keyword">auto</span> it = std::lower_bound(v.cbegin(), v.cend(), value, [](<span class="keyword">const</span> T &amp;value, <span class="keyword">const</span> T &amp;element)</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;                                   { return value &lt;= element; });</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        <span class="keywordflow">if</span> (it == v.cend())</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        {</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;            <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        }</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        <span class="keywordflow">return</span> v.cend() - it;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ade6351fc70292dcaf68d2e1a706db301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6351fc70292dcaf68d2e1a706db301">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hsc_snippets::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1___interval.html">_Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interval__map_8hpp_source.html#l00036">36</a> of file <a class="el" href="interval__map_8hpp_source.html">interval_map.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="keywordflow">return</span> interval.right &lt;= x;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="interval__map_8hpp_source.html#l00016">hsc_snippets::_Interval&lt; T &gt;::right</a>.</p>

</div>
</div>
<a id="a40c7b37bbc72584a6f44b005fce7e90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c7b37bbc72584a6f44b005fce7e90a">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hsc_snippets::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1___interval.html">_Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1___interval.html">_Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interval__map_8hpp_source.html#l00047">47</a> of file <a class="el" href="interval__map_8hpp_source.html">interval_map.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    {</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">return</span> interval1.left &lt; interval2.left;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="interval__map_8hpp_source.html#l00015">hsc_snippets::_Interval&lt; T &gt;::left</a>.</p>

</div>
</div>
<a id="a9d77ba741533e46a1e0326a2e7b8442c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d77ba741533e46a1e0326a2e7b8442c">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hsc_snippets::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhsc__snippets_1_1___interval.html">_Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interval__map_8hpp_source.html#l00041">41</a> of file <a class="el" href="interval__map_8hpp_source.html">interval_map.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        <span class="keywordflow">return</span> x &lt; interval.left;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="interval__map_8hpp_source.html#l00015">hsc_snippets::_Interval&lt; T &gt;::left</a>.</p>

</div>
</div>
<a id="a6f8f2987db631e9af726376704c355b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8f2987db631e9af726376704c355b8">&#9670;&nbsp;</a></span>postorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::postorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Post-order traversal of a binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node of the binary tree. </td></tr>
    <tr><td class="paramname">func</td><td>Function to process each node's value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="binary__tree_8hpp_source.html#l00138">138</a> of file <a class="el" href="binary__tree_8hpp_source.html">binary_tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    {</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keywordflow">if</span> (root == <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160; </div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <a class="code" href="namespacehsc__snippets.html#a6f8f2987db631e9af726376704c355b8">postorder</a>(root-&gt;left, func);</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        <a class="code" href="namespacehsc__snippets.html#a6f8f2987db631e9af726376704c355b8">postorder</a>(root-&gt;right, func);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        func(root-&gt;val);</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_a6f8f2987db631e9af726376704c355b8"><div class="ttname"><a href="namespacehsc__snippets.html#a6f8f2987db631e9af726376704c355b8">hsc_snippets::postorder</a></div><div class="ttdeci">void postorder(TreeNode *root, std::function&lt; void(int)&gt; func)</div><div class="ttdef"><b>Definition:</b> <a href="binary__tree_8hpp_source.html#l00138">binary_tree.hpp:138</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="binary__tree_8hpp_source.html#l00016">hsc_snippets::TreeNode::left</a>, <a class="el" href="binary__tree_8hpp_source.html#l00017">hsc_snippets::TreeNode::right</a>, and <a class="el" href="binary__tree_8hpp_source.html#l00015">hsc_snippets::TreeNode::val</a>.</p>

</div>
</div>
<a id="a32df3d871f5bcd99ec98038fe7d7ae02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32df3d871f5bcd99ec98038fe7d7ae02">&#9670;&nbsp;</a></span>preorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::preorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhsc__snippets_1_1_tree_node.html">TreeNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(int)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pre-order traversal of a binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node of the binary tree. </td></tr>
    <tr><td class="paramname">func</td><td>Function to process each node's value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="binary__tree_8hpp_source.html#l00124">124</a> of file <a class="el" href="binary__tree_8hpp_source.html">binary_tree.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    {</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">if</span> (root == <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        func(root-&gt;val);</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <a class="code" href="namespacehsc__snippets.html#a32df3d871f5bcd99ec98038fe7d7ae02">preorder</a>(root-&gt;left, func);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        <a class="code" href="namespacehsc__snippets.html#a32df3d871f5bcd99ec98038fe7d7ae02">preorder</a>(root-&gt;right, func);</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_a32df3d871f5bcd99ec98038fe7d7ae02"><div class="ttname"><a href="namespacehsc__snippets.html#a32df3d871f5bcd99ec98038fe7d7ae02">hsc_snippets::preorder</a></div><div class="ttdeci">void preorder(TreeNode *root, std::function&lt; void(int)&gt; func)</div><div class="ttdef"><b>Definition:</b> <a href="binary__tree_8hpp_source.html#l00124">binary_tree.hpp:124</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="binary__tree_8hpp_source.html#l00016">hsc_snippets::TreeNode::left</a>, <a class="el" href="binary__tree_8hpp_source.html#l00017">hsc_snippets::TreeNode::right</a>, and <a class="el" href="binary__tree_8hpp_source.html#l00015">hsc_snippets::TreeNode::val</a>.</p>

</div>
</div>
<a id="a98e8a5e4bd9f4c58c06e7f66240b167c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e8a5e4bd9f4c58c06e7f66240b167c">&#9670;&nbsp;</a></span>SieveOfEratosthenes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; hsc_snippets::SieveOfEratosthenes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements the Sieve of Eratosthenes algorithm to find all prime numbers up to a given limit n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The upper limit (inclusive) up to which prime numbers are to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector&lt;int&gt; containing all the prime numbers less than or equal to n. </dd></dl>

<p class="definition">Definition at line <a class="el" href="number__utils_8hpp_source.html#l00095">95</a> of file <a class="el" href="number__utils_8hpp_source.html">number_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    {</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="comment">// Initialize a boolean vector &quot;prime&quot; with entries up to n. All entries are initially set to true.</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        <span class="comment">// A value in prime[i] will be false if i is not a prime number, and true if it is a prime number.</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        std::vector&lt;bool&gt; prime(n + 1, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        prime[0] = prime[1] = <span class="keyword">false</span>; <span class="comment">// 0 and 1 are not considered prime numbers.</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160; </div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="comment">// This vector will store all the prime numbers found.</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        std::vector&lt;int&gt; primes;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160; </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="comment">// Start iterating from the first prime number, 2, up to the square root of n.</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="comment">// We only need to go up to sqrt(n) because if n has a divisor greater than sqrt(n),</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        <span class="comment">// it must also have a smaller one, so all composites will have been marked by this point.</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p = 2; p &lt;= std::sqrt(n); ++p)</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            <span class="comment">// If prime[p] is true, then it is a prime number.</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            <span class="keywordflow">if</span> (prime[p])</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            {</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                <span class="comment">// Mark all multiples of p starting from p^2 as not prime.</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                <span class="comment">// Starting from p^2 because all smaller multiples of p would have already been marked by smaller primes.</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = p * p; i &lt;= n; i += p)</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                {</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                    prime[i] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                }</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            }</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        }</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160; </div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="comment">// Collect all prime numbers: iterate over the range up to n and</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        <span class="comment">// add the number to the primes list if its corresponding value in the prime vector is true.</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p = 2; p &lt;= n; ++p)</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        {</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            <span class="keywordflow">if</span> (prime[p])</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                primes.push_back(p);</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            }</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        }</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160; </div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <span class="comment">// Return the vector containing all the primes found.</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keywordflow">return</span> primes;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b3d0574aec6857720f3494a33cc7a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3d0574aec6857720f3494a33cc7a85">&#9670;&nbsp;</a></span>smallest_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::integral I = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I hsc_snippets::smallest_index </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the smallest index in a non-decreasing array where the function applied to the index returns a value greater than or equal to the specified value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value against which the function's results are compared. </td></tr>
    <tr><td class="paramname">I</td><td>The integral type of the index, defaulting to int. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>The lower bound of the search range (inclusive). </td></tr>
    <tr><td class="paramname">high</td><td>The upper bound of the search range (inclusive). </td></tr>
    <tr><td class="paramname">value</td><td>The value to compare against the function's results. </td></tr>
    <tr><td class="paramname">func</td><td>The function to apply to each index, expected to return non-decreasing values for the range [low, high]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest index for which func(index) &gt;= value, or -1 if no such index exists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sorted__utils_8hpp_source.html#l00119">119</a> of file <a class="el" href="sorted__utils_8hpp_source.html">sorted_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    {</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        I ans = -1; <span class="comment">// Initialize answer to -1 to indicate no valid index found yet</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="keywordflow">while</span> (low &lt;= high)</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        {</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;            I mid = low + (high - low) / 2; <span class="comment">// Calculate the mid-point of the current search range</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            T res = func(mid);              <span class="comment">// Evaluate the function at the mid-point</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            <span class="keywordflow">if</span> (res &gt;= value)</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                ans = mid;      <span class="comment">// Update answer since res is greater than or equal to value</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                high = mid - 1; <span class="comment">// Narrow the search to the left half to find the smallest index</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            }</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            {</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                low = mid + 1; <span class="comment">// Narrow the search to the right half since res is less than value</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;            }</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        }</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160; </div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keywordflow">return</span> ans; <span class="comment">// Return the found index or -1 if no such index exists</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adbdb05e51cc5a1ab1a9b3aea8075b2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdb05e51cc5a1ab1a9b3aea8075b2ef">&#9670;&nbsp;</a></span>sortThree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hsc_snippets::sortThree </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts three elements in non-decreasing order using a simple comparison and swap algorithm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements to be sorted. Must be an integral type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Reference to the first element, will be the smallest after sorting. </td></tr>
    <tr><td class="paramname">b</td><td>Reference to the second element, will be the middle element after sorting. </td></tr>
    <tr><td class="paramname">c</td><td>Reference to the third element, will be the largest after sorting. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sorted__utils_8hpp_source.html#l00149">149</a> of file <a class="el" href="sorted__utils_8hpp_source.html">sorted_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    {</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordflow">if</span> (a &gt; b)</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        {</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            std::swap(a, b);</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        }</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        <span class="keywordflow">if</span> (b &gt; c)</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            std::swap(b, c);</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        }</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        <span class="keywordflow">if</span> (a &gt; b)</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        {</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            std::swap(a, b);</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        }</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e6dae9bb445381d5ec6a88094c9f315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6dae9bb445381d5ec6a88094c9f315">&#9670;&nbsp;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::sum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="varadic__numeric_8hpp_source.html#l00064">64</a> of file <a class="el" href="varadic__numeric_8hpp_source.html">varadic_numeric.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        <span class="keywordflow">return</span> x;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="segment__tree_8hpp_source.html#l00029">hsc_snippets::SegmentTree&lt; T &gt;::_range_sum()</a>, and <a class="el" href="varadic__numeric_8hpp_source.html#l00069">sum()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_a3e6dae9bb445381d5ec6a88094c9f315_icgraph.png" border="0" usemap="#anamespacehsc__snippets_a3e6dae9bb445381d5ec6a88094c9f315_icgraph" alt=""/></div>
<map name="anamespacehsc__snippets_a3e6dae9bb445381d5ec6a88094c9f315_icgraph" id="anamespacehsc__snippets_a3e6dae9bb445381d5ec6a88094c9f315_icgraph">
<area shape="rect" title=" " alt="" coords="499,42,641,69"/>
<area shape="rect" href="classhsc__snippets_1_1_segment_tree.html#ae1ca5c52f89a6db8aadcd994dfa4d3c3" title=" " alt="" coords="252,5,451,47"/>
<area shape="rect" href="namespacehsc__snippets.html#adabb6992d6adc87e88949774ea718c67" title=" " alt="" coords="280,71,423,98"/>
<area shape="rect" href="classhsc__snippets_1_1_segment_tree.html#a9254a4a7d413e0887fb7cfea28775cb7" title=" " alt="" coords="5,5,204,47"/>
</map>
</div>

</div>
</div>
<a id="adabb6992d6adc87e88949774ea718c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabb6992d6adc87e88949774ea718c67">&#9670;&nbsp;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numeric T, numeric... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hsc_snippets::sum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="varadic__numeric_8hpp_source.html#l00069">69</a> of file <a class="el" href="varadic__numeric_8hpp_source.html">varadic_numeric.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keywordflow">return</span> x + <a class="code" href="namespacehsc__snippets.html#adabb6992d6adc87e88949774ea718c67">sum</a>(args...);</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_adabb6992d6adc87e88949774ea718c67"><div class="ttname"><a href="namespacehsc__snippets.html#adabb6992d6adc87e88949774ea718c67">hsc_snippets::sum</a></div><div class="ttdeci">T sum(T x, Args... args)</div><div class="ttdef"><b>Definition:</b> <a href="varadic__numeric_8hpp_source.html#l00069">varadic_numeric.hpp:69</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="varadic__numeric_8hpp_source.html#l00064">sum()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_adabb6992d6adc87e88949774ea718c67_cgraph.png" border="0" usemap="#anamespacehsc__snippets_adabb6992d6adc87e88949774ea718c67_cgraph" alt=""/></div>
<map name="anamespacehsc__snippets_adabb6992d6adc87e88949774ea718c67_cgraph" id="anamespacehsc__snippets_adabb6992d6adc87e88949774ea718c67_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,148,32"/>
<area shape="rect" href="namespacehsc__snippets.html#a3e6dae9bb445381d5ec6a88094c9f315" title=" " alt="" coords="196,5,339,32"/>
</map>
</div>

</div>
</div>
<a id="a64970a5102d416fdd499f71c3cd1000f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64970a5102d416fdd499f71c3cd1000f">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a vector of strings to its string representation, with elements separated by commas. The resulting string is enclosed in square brackets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of strings to convert. Each element in the vector is expected to be a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the vector's contents, formatted as "[element1, element2, ...]". If the vector is empty, the returned string will be "[]". </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__utils_8hpp_source.html#l00143">143</a> of file <a class="el" href="string__utils_8hpp_source.html">string_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    {</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        std::stringstream ss;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        ss &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec.size(); ++i)</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        {</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;            ss &lt;&lt; vec[i];</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            <span class="keywordflow">if</span> (i &lt; vec.size() - 1)</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            { <span class="comment">// Check if it&#39;s not the last element</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                ss &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            }</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        }</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        ss &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="keywordflow">return</span> ss.str();</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4e59e0f34998f66297969f24854dbadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e59e0f34998f66297969f24854dbadb">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a vector of vectors of integral type T to its string representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of elements in the vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of vectors to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the vector of vectors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__utils_8hpp_source.html#l00167">167</a> of file <a class="el" href="string__utils_8hpp_source.html">string_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        std::stringstream ss;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        ss &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec.size(); ++i)</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        {</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            ss &lt;&lt; <a class="code" href="namespacehsc__snippets.html#a4e59e0f34998f66297969f24854dbadb">to_string</a>(vec[i]);</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;            <span class="keywordflow">if</span> (i &lt; vec.size() - 1)</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;            { <span class="comment">// Check if it&#39;s not the last element</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                ss &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            }</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        }</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        ss &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keywordflow">return</span> ss.str();</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    }</div>
<div class="ttc" id="anamespacehsc__snippets_html_a4e59e0f34998f66297969f24854dbadb"><div class="ttname"><a href="namespacehsc__snippets.html#a4e59e0f34998f66297969f24854dbadb">hsc_snippets::to_string</a></div><div class="ttdeci">std::string to_string(const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;vec)</div><div class="ttdef"><b>Definition:</b> <a href="string__utils_8hpp_source.html#l00167">string_utils.hpp:167</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="string__utils_8hpp_source.html#l00119">to_string()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_a4e59e0f34998f66297969f24854dbadb_cgraph.png" border="0" usemap="#anamespacehsc__snippets_a4e59e0f34998f66297969f24854dbadb_cgraph" alt=""/></div>
<map name="anamespacehsc__snippets_a4e59e0f34998f66297969f24854dbadb_cgraph" id="anamespacehsc__snippets_a4e59e0f34998f66297969f24854dbadb_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,176,32"/>
<area shape="rect" href="namespacehsc__snippets.html#aea5a6b2a2e32759546fc105652ee34c6" title=" " alt="" coords="224,5,395,32"/>
</map>
</div>

</div>
</div>
<a id="aea5a6b2a2e32759546fc105652ee34c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5a6b2a2e32759546fc105652ee34c6">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string hsc_snippets::to_string </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a vector of integral type T to its string representation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The integral type of elements in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__utils_8hpp_source.html#l00119">119</a> of file <a class="el" href="string__utils_8hpp_source.html">string_utils.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    {</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        std::stringstream ss;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        ss &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec.size(); ++i)</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            ss &lt;&lt; vec[i];</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            <span class="keywordflow">if</span> (i &lt; vec.size() - 1)</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            { <span class="comment">// Check if it&#39;s not the last element</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                ss &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            }</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        }</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        ss &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <span class="keywordflow">return</span> ss.str();</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="string__utils_8hpp_source.html#l00167">to_string()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacehsc__snippets_aea5a6b2a2e32759546fc105652ee34c6_icgraph.png" border="0" usemap="#anamespacehsc__snippets_aea5a6b2a2e32759546fc105652ee34c6_icgraph" alt=""/></div>
<map name="anamespacehsc__snippets_aea5a6b2a2e32759546fc105652ee34c6_icgraph" id="anamespacehsc__snippets_aea5a6b2a2e32759546fc105652ee34c6_icgraph">
<area shape="rect" title=" " alt="" coords="224,5,395,32"/>
<area shape="rect" href="namespacehsc__snippets.html#a4e59e0f34998f66297969f24854dbadb" title=" " alt="" coords="5,5,176,32"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a218d0181825bcf526ca9e5c24f6aab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218d0181825bcf526ca9e5c24f6aab06">&#9670;&nbsp;</a></span>MODULO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int hsc_snippets::MODULO = static_cast&lt;int&gt;(1e9 + 7)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="modular__arithmetic_8hpp_source.html#l00010">10</a> of file <a class="el" href="modular__arithmetic_8hpp_source.html">modular_arithmetic.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="modular__arithmetic_8hpp_source.html#l00020">additive_inverse()</a>, <a class="el" href="modular__arithmetic_8hpp_source.html#l00012">modular_add()</a>, <a class="el" href="modular__arithmetic_8hpp_source.html#l00052">modular_cube()</a>, <a class="el" href="modular__arithmetic_8hpp_source.html#l00037">modular_multiply()</a>, <a class="el" href="modular__arithmetic_8hpp_source.html#l00061">modular_pow2()</a>, <a class="el" href="modular__arithmetic_8hpp_source.html#l00045">modular_square()</a>, and <a class="el" href="modular__arithmetic_8hpp_source.html#l00027">modular_substract()</a>.</p>

</div>
</div>
<a id="a587d75f6d3f1594e5893f3fec11925c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587d75f6d3f1594e5893f3fec11925c2">&#9670;&nbsp;</a></span>numeric</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept hsc_snippets::numeric = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="varadic__numeric_8hpp_source.html#l00009">9</a> of file <a class="el" href="varadic__numeric_8hpp_source.html">varadic_numeric.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 28 2024 13:16:12 for snippets by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
