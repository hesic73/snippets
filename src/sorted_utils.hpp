#ifndef SORTED_UTILS_H
#define SORTED_UTILS_H

#include <vector>
#include <concepts>
#include <optional>
#include <functional>

namespace hsc_snippets {
    template<std::totally_ordered T>
    int numOfGreaterElements(const std::vector<T> &v, T value)
    // v should be non-descreasing
    {
        auto it = std::lower_bound(v.cbegin(), v.cend(), value,
                                   [](const T &value, const T &element) { return value <= element; });
        if (it == v.cend()) {
            return 0;
        }
        return v.cend() - it;
    }

    template<std::integral T>
    // vec must be in ascending order. [start, end)
    bool containsInRange(const std::vector<T> &vec, T start, T end) {
        if (vec.empty() || start >= end) {
            return false;
        }

        // Lower bound of the range
        auto lower = std::lower_bound(vec.begin(), vec.end(), start);

        // Check if the lower bound is not beyond the vector and less than 'end'
        if (lower != vec.end() && *lower < end) {
            return true;
        }

        return false;
    }

    template<typename T, std::integral I = int>
    /**
     * Performs a binary search on a function-generated sequence of values to find a specific value.
     * This function assumes that the values generated by `func` are in a non-decreasing order
     * within the specified range of indices.
     *
     * @tparam T The type of the values generated by the function and the type of `value`.
     * @tparam I The integral type used for indexing, with a default of int.
     * @param low The lowest index of the search range (inclusive).
     * @param high The highest index of the search range (inclusive).
     * @param value The target value to search for within the function-generated sequence.
     * @param func A callable that takes an index of type I and returns a value of type T.
     *        This function must return values in a non-decreasing order over the range [low, high].
     * @return std::optional<I> containing the index at which the value equals `func(index)`,
     *         or std::nullopt if no such index exists.
     */
    std::optional<I> deferred_binary_search(I low,
                                            I high,
                                            const T &value,
                                            auto &&func) {
        while (low <= high) {
            I mid = low + (high - low) / 2;
            T res = func(mid);
            if (res == value) {
                return mid;
            } else if (res < value) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return std::nullopt;
    }


    template<typename T, std::integral I = int>
    /**
     * Finds the first position in [low, high] where func(position) is strictly greater than value,
     * using a custom comparator.
     *
     * @param low The start of the search range (inclusive).
     * @param high The end of the search range (inclusive).
     * @param value The target value for comparison.
     * @param func A callable that returns values in a non-decreasing order.
     * @param comp A comparator to compare func(position) and value.
     * @return The index of the first position where comp(value, func(position)) returns true.
     */
    I deferred_upper_bound(I low, I high, const T &value, auto &&func, auto &&comp) {
        I it;
        I count = high - low + 1;
        I step;

        while (count > 0) {
            it = low;
            step = count / 2;
            it += step;

            if (comp(value, func(it))) {
                count = step;
            } else {
                low = ++it;
                count -= step + 1;
            }
        }

        return low;
    }

    template<typename T, std::integral I = int>
    /**
     * Finds the first position in [low, high] where func(position) is strictly greater than value.
     *
     * @param low The start of the search range (inclusive).
     * @param high The end of the search range (inclusive).
     * @param value The target value for comparison.
     * @param func A callable that returns values in a non-decreasing order.
     * @return The index of the first position where func(position) is greater than value.
     */
    I deferred_upper_bound(I low, I high, const T &value, auto &&func) {
        return deferred_upper_bound(low, high, value, func, std::less<T>());
    }

    template<typename T, std::integral I = int>
    /**
     * Finds the first position in [low, high] where func(position) is greater than or equal to value,
     * using a custom comparator.
     *
     * @param low The start of the search range (inclusive).
     * @param high The end of the search range (inclusive).
     * @param value The target value for comparison.
     * @param func A callable that returns values in a non-decreasing order.
     * @param comp A comparator to compare func(position) and value.
     * @return The index of the first position where !comp(func(position), value).
     */
    I deferred_lower_bound(I low, I high, const T &value, auto &&func, auto &&comp) {
        I it;
        I count = high - low + 1;
        I step;

        while (count > 0) {
            it = low;
            step = count / 2;
            it += step;

            if (comp(func(it), value)) {
                low = ++it;
                count -= step + 1;
            } else {
                count = step;
            }
        }

        return low; // Returns the first index where the value is not less than the target value
    }

    template<typename T, std::integral I = int>
    /**
     * Finds the first position in [low, high] where func(position) is greater than or equal to value.
     *
     * @param low The start of the search range (inclusive).
     * @param high The end of the search range (inclusive).
     * @param value The target value for comparison.
     * @param func A callable that returns values in a non-decreasing order.
     * @return The index of the first position where func(position) is not less than value.
     */
    I deferred_lower_bound(I low, I high, const T &value, auto &&func) {
        return deferred_lower_bound(low, high, value, func, std::less<T>());
    }


    /**
     * Sorts three elements in non-decreasing order using a simple comparison and swap algorithm.
     *
     * @tparam T The type of the elements to be sorted. Must be an integral type.
     * @param a Reference to the first element, will be the smallest after sorting.
     * @param b Reference to the second element, will be the middle element after sorting.
     * @param c Reference to the third element, will be the largest after sorting.
     */
    template<std::integral T>
    void sortThree(T &a, T &b, T &c) {
        if (a > b) {
            std::swap(a, b);
        }
        if (b > c) {
            std::swap(b, c);
        }
        if (a > b) {
            std::swap(a, b);
        }
    }

    /**
     * Creates a compression mapper function for the given vector of integers.
     *
     * This function performs coordinate compression on the input vector `nums`,
     * mapping each unique value to a continuous index in ascending order starting from 0.
     * The returned function allows for efficient lookup of the compressed index
     * corresponding to any value in the original vector.
     *
     * @param nums The input vector of integers to be compressed. The vector can contain duplicate values.
     * @return A function that maps an integer to its compressed index. The compressed index represents
     *         the position of the integer in the sorted, unique version of `nums`.
     *
     * @note The returned function captures the compressed vector by value, ensuring the
     *       integrity and lifespan of the data required for index lookup.
     */
    static std::function<int(int)> create_compression_mapper(const std::vector<int> &nums) {
        std::vector<int> compressed = nums;
        std::sort(compressed.begin(), compressed.end());
        compressed.erase(std::unique(compressed.begin(), compressed.end()), compressed.end());

        return [compressed](int value) {
            return std::lower_bound(compressed.begin(), compressed.end(), value) - compressed.begin();
        };
    }
}

#endif // SORTED_UTILS_H
